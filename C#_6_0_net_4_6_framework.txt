				PART II - Core C# Programming

		Chapter 3 - Core C# Programming Constructs, Part I

Type is a general term referring to a member of the set {class, interface, structure, enumeration, delegate}.
In C# it is not possible to create global functions or global points of data.
Every executable C# application (console program, Windows desktop program, or Windows service) must contain 
a class defining a Main() method, which is used to signify the entry point of the application.

Be aware that all C# keywords are lowercase (e.g., public, lock, class, dynamic), while namespaces, types,
and member names begin (by convention) with an initial capital letter and have capitalized the first
letter of any embedded words (e.g. System.Windows.MessageBox).

By convention, returning the value 0 indicates the program has terminated successfully, while another value
(such as -1) represents an error condition.

Console.WriteLine() pumps a text string (including a carriage return) to the output stream.
Console.Write() method pumps text to the output stream without a carriage return.
Console.ReadLine() allows you to receive information from the input stream up until the Enter key is pressed.
Console.Read() is used to capture a single character from the input stream.

The C# data type keywords are actually shorthand notations for full-blown types in the System namespace.

All intrinsic data types support what is known as a default constructor. This feature allows you to create
a variable using the new keyword, which automatically sets the variable to its default value:
- bool variables are set to false
- numeric data is set to 0 (or 0.0 in the case of floating-point data types)
- char variables are set to a single empty character
- biginteger variables are set to 0
- datetime variables are set to 1/1/0001 12:00:00 AM
- object references (including strings) are set to null

If you have more uniquely numbered curly-bracket placeholders than fill arguments, you will receive a format
exception at runtime. However, if you have more fill arguments than placeholders, the unused fill arguments
are ignored.

It is possible to position each placeholder in any location within a string literal, and it need not follow
an increasing sequence.

It is a compiler error to make use of a local variable before assigning an initial value.

It is also permissible to declare multiple variables of the same underlying type on a single line of code.

Default values of the variables:
- bool variables are set to false
- numeric data is set to 0 (or 0.0 in the case of float-point data types)
- char variables are set to a single empty character
- BigInteger variables are set to 0.
- DateTime variables are set to 1/1/0001 12:00:00 AM
- Object reference (including strings) are set to null

Many members of System.Char have two calling conventions: a single character or a string with a numerical index that
specifies the position of the character to test.

The DateTime type contains data that represents a specific date (month, day, year) and time value, both of which
may be formatted in a variety of ways using the supplied members. The TimeSpan structure allows you to easily
define and transform units of time using various members.

string variables can be connected together to build larger strings via the C# + (as well as +=) operator.
This techique is formally termed string concatenation.

C# string literals may contain various escape characters, which qualify how the character data should be printed
to the output stream.

---------------------------------------------------------------------------------------------------------------------
Character	|	Meaning in Life										     |
---------------------------------------------------------------------------------------------------------------------
\'		|	Inserts a single quote into a string literal.						     |
\"		|	Inserts a double quote into a string literal.						     |
\\		|	Inserts a backslash into a string literal. This can be quite helpful when defining file or   |
		|	network path.										     |
\a		|	Triggers a system alert (beep). For console programs, this can be an audio clue to the user. |
\n		|	Inserts a new line (on Windows platforms).						     |
\r		|	Inserts a carriage return.								     |
\t		|	Inserts a horizontal tab into the string literal.					     |
---------------------------------------------------------------------------------------------------------------------

When you prefix a string literal with the @ symbol, you have created what is termed a verbatim string.
Using verbatim string, you disable the processing of a literal's escape characters and print out a string as is.

A reference type is an object allocated on the garbage-collected managed heap.

The string data type is indeed a reference type, the equality operators have been redefined to compare the values
of string objects, not the object in memory to which they refer.

The C# equality operators perform a case-sensitive, character-by-character equality test on string objects.

One of the interesting aspects of System.String is that after you assign a string object with its initial value,
the character data cannot be changed (strings are immutable). If you look more closely at what is happening
behind the scenes, you will notice the methods of the string type are, in fact, returning you a new string object
in a modified format.

Widening is the term used to define an implicit upward cast that does not result in a loss of data.

Narrowing is the logical opposite of widening, in that a larger value is stored within a smaller data type variable.

When you wrap a statement (or a block of statements) within the scope of the checked keyword, the C# compiler
emits additional CIL instructions that test for overflow conditions that may result when adding, multiplying,
subtracting, or dividing two numerical data types.

C# provides the unchecked keyword to disable the throwing of an overflow exception on a case-by-case basis.

The C# language does provide for implicitly typing of local variables using the var keyword. The compiler will
automatically infer the underlying data type based on the initial value used to initialize the local
data point. There are various restrictions regarding the use of the var keyword. First, implicit typing applies
only to local variables in a method or property scope. It is illegal to use the var keyword to define return 
values, parameters, or field data of a custom type. Also, local variables declared with the var keyword
must be assigned an initial value at the exact time of declaration and cannot be assigned the initial value
of null. This last restriction should make sense, given that the compiler cannot infer what sort of type
in memory the variable would be pointing to based only to null. It is permissible, however, to assign 
an inferred local variable to null after its initial assignment (provided it is a reference type). Futhermore,
it is permissible to assign the value of an implicitly typed local variable to the value of other variables,
implicitly typed or not. Also, it is permissible to return an implicitly typed local variable to the caller, 
provided the method return type is the same underlying type as the var-defined data point.

Be aware that implicit typing of local variales results in strongly typed data. Therefore, use of the var keyword
is not the same technique used with scripting languages (such as JavaScript or Perl) or the COM Variant data type,
where a variable can hold values of different types over its lifetime in a program (often termed dynamic typing).

C# does allow for dynamic typing in C# using a keyword called dynamic.

C# provides the following four iteration constructs:
- for
- foreach/in
- while
- do/while

For - when you need to iterate over a block of code a fixed number of times, the for statement provides a good deal
of flexibility. In essence, you are able to specify how many times a block of code repeats itself, as well as the 
terminating condition. You can create complex terminating conditions, build endless loops, loop in reverse (via the
-- operator), and use the goto, continue, and break jump keywords.

Foreach - allows you to iterate over all items in a container without the need to test for an upper limit.
Unlike a for loop, however, the foreach loop will walk the container only in a linera (n+1) fashion.

While - the looping construct is useful should you want to execute a block of statements until some terminating
condition has been reached. Within the scope of a while loop, you will need to ensure this terminating event is 
indeed established; otherwise, you will be stuck in an endless loop.

Do/while - is used when you need to perform some action an undetermined number of times. The difference is that 
do/while loops are guaranteed to execute the corresponding block of code at least once. In contrast, it is possible
that a simple while loop may never execute if the terminating condition is false from onset.

		Chapter 4 - Core Programming Constructs, Part II

C# Parameter Modifiers
---------------------------------------------------------------------------------------------------------------------------
Parameter	|	Meaning in Life											  |
Modifier	|													  |
--------------------------------------------------------------------------------------------------------------------------
(None)		|	If a parameter is not marked with a parameter modifier, it is assumed to passed by value,	  |
		|	meaning the called method receives a copy of the original data.					  |
out		|	Output parameters must be assigned by the method being called and, therefore, are passed	  |
		|	by reference. If the called method fails to assign output parameters, you are issued 		  |
		|	a compiled error.										  |
ref		|	The value is initially assigned by the caller and may be optionally modified by the called	  |
		|	method (as the data is also passed by reference). No compiler error is generated if 		  |
		|	the called method fails to assign a ref parameter.						  |
params		|	This parameter modifier allows you to send in a variable number of arguments as a single 	  |
		|	logical parameter. A method can have only a single params modifier, and it must be the final	  |
		|	parameter of the method. In reality, you might not need to use the params modifier all too often; |
		|	however, be aware that numerous methods within the base class libraries do make use of this	  |	
		|	C# language feature										  |
--------------------------------------------------------------------------------------------------------------------------

The default manner in which a parameter is sent into a function is by value.

Methods that have been defined to take output parameters (via the out keyword) are under obligation to assign them
to an appropriate value before exiting the method scope (if you fail to do so, you will receive compiler errors).
Calling a method with output parameters also requires the use of the out modifier.
However, the logical variables that are passed as output variables are not required to be assigned before 
passing them in as output parameters (if you do so, the original value is lost after the call). The reason the compiler
allows you to send in seemingly unassigned data is because the method being called must take an assignment.
Finally, always remember that a method that defines output parameters must assign the parameter to a valid value
before exiting the method scope.

Reference (ref) parameters are necessary when you want to allow a method to operate on (and usually change the values of)
various data points declared in the caller's scope (such as a sorting or swapping routine). Note the distinction 
between output and reference parameters:
- output parameters do not need to be initialized before they passed to the method. The reason for this is that
the method must assign output parameters before exiting.
- reference parameters must be initilized before they are passed to the method. The reason for this is that you are passing
a reference to an existing variable. If you don't assign it to an initial value, that would be the equivalent of operating on an
unassigned local variable.

C# supports the use of parameter arrays using the params keyword. If you were to prototype a method to take an array 
of doubles, this would force the caller to first define the array, then fill the array, and finally pass it into the method.

To avoid any ambiguity, C# demands a method support only a single params argument, which must be the final argument
in the parameter list.

C# allows you to create methods that can take optional arguments. This technique allows the caller to invoke a single method
while omitting arguments deemed unnecessary, provided the caller is happy with the specific defaults.
One important thing to be aware of is that the value assigned to an optional parameter must be known at compile time 
and cannot be resolved at runtime (if you attempt to do so, you'll receive compile-time errors!).
To avoid ambiguity, optional parameters must always be packed onto the end of a method signature. It is a compiler error
to have optional parameters listed before nonoptional parameters.

Like other modern object-oriented languages, C# allows a method to be overloaded. Simply put, when you define a set of
identically named methods that differ by the number (or type) of parameters, the method in question is said to be
overloaded.

It is possible to build generic methods that take the concept of overloading to the next level. Using generics, you can 
define type placeholders for a method implementation that are specified at the time you invoke the member in question.

Do be aware that if you declare an array but do not explicitly fill each index, each item will be set to the default value
of the data type (e.g., an array of bools will be set to false or an array of ints will be set to 0).
In addition to filling an array element by element, you are also able to fill the items of an array using C# array
initialization syntax. To do so, specify each array item within the scope of curly brackets ({}).
Notice that when you make use of this "curly-bracket" syntax, you do not need to specify the size of the array,
given that this will be inferred by the number of items within the scope of the curly brackets.
Also notice that the use of the new keyword is optional.

The var keyword allows you to define a variable, whose underlying type is determined by the compiler.

In addition to the single-dimension arrays you have been seen thus far, C# also supports two varieties of
multidimensional arrays:
1) a rectangular array, which is simply an array of multiple dimensions, where each row is of the same length
2) a jagged array, which contains some number of inner arrays, each of which may have a different upper limit

After you have created an array, you are free to pass it as an argument or receive it as a member return value.

An enum is a custom data type of name-value pairs. An enumerator is a class of structure that implements
a .NET interface named IEnumerable.

The first element in the enum is set to the value zero (0), followed by an n + 1 progression.
Elements of an enumeration need not be sequential!

Once you have established the range and storage type of your enumeration, you can use it in place of so-called
magic numbers. Because enumerations are nothing more than a user-defined data type, you are able to use them as 
function return values, method parameters, local variables, and so forth.

Structure types are well suited for modeling mathematical, geometrical, and other "atomic" entities
in your application. A structure (such as an enumeration) is a used-defined type; however, 
structures are not simply a collection of name-value pairs. Rather, structures are types that can contain
any number of data fields and members that operate on these fields.

You can think of a structure as a "lightweight class type", given that structures provide a way to define a type
that supports encapsulation but cannot be used to build a family of related types. When you need to build a family
of related types through inheritance, you will need to make use of class types.

In C#, structures are defined using the struct keyword.

You can create structure variables using the C# new keyword, which will invoke the structure's default constructor.
By definition, a default constructor does not take any arguments. The benefit of invoking the default constructor of a structure
is that each piece of field data is automatically set to its default value.

It is also possible to design a structure with a custom constructor. This allows you to specify the values of field data
upon variable creation rather than having to set each data member field by field.

Unlike arrays, strings, or enumerations, C# structures do not have an identically named representation in the .NET library
(that is, there is no System.Structure class) but are implicitly derived from System.ValueType. Simply put, the role of
System.ValueType is to ensure that the derived type (e.g., any structure) is allocated on the stack, rather than
the garbage-collected heap. Simply put, data allocated on the stack can be created and destroyed quickly, as its lifetime
is determined by the defining scope. Heap-allocated data, on the other hand, is monitored by the .NET garbage collector and 
has a lifetime that is determined by a large number of factors.
Functionally, the only purpose of System.ValueType is to override the virtual methods defined by System.Object to use
value-based, versus reference-based, semantics.

// Structures and enumerations are implicitly extend System.ValueType.
public abstract class ValueType: object
{
   public virtual bool Equals(object obj);
   public virtual int GetHashCode();
   public Type GetType();
   public virtual string ToString();
}

Given that value types are using value-based semantics, the lifetime of a structure (which includes all numerical
data types [int, float], as well as any enum or structure) is predictable. When a structure variable falls out
of the defining scope, it is removed from memory immediately.

When you assign one value type to another, a member-by-member copy of the field data is achieved.

The golden rule to keep in mind when passing reference types is the following:
- if a reference type is passed by reference, the caller may change the values of the object's state data, 
  as well as the object it is referencing
- if a reference type is passed by value, the caller may change the value of the object's state data
  but not the object it is referencing

Value Types and Reference Types Comparison
----------------------------------------------------------------------------------------------------------------------------------------
Intriguing Question				Value Type					Reference Type				|
---------------------------------------------------------------------------------------------------------------------------------------	|
Where are objects allocated?		Allocated on the stack.				Allocated on the managed heap.			|
																	|
How is a variable represented?		Value type variables are local copies.		Reference type variables are pointing to the 	|
											memory occupied by the allocated instance.	|
																	|
What is the base type?			Implicitly extends System.ValueType.		Can derive from any other (except		|
											System.ValueType), as long as that type		|
											is not "sealed".				|
																	|
Can this type function as a base	No. Value types are always sealed		Yes. If the type is not sealed, it may		|
to other types?				and cannot be inherited from.			function as a base to other types.		|
																	|
What is the default parameter		Variables are passed by value (i.e.,		For reference types, the reference is copied	|
passing behavior?			a copy of the variable is passed		by value.					|
					into the called function).									|
																	|
Can this type override			No.						Yes, indirectly.				|
System.Object.Finalize()?														|
																	|
Can I define constructors		Yes, but the default constructor		But, of course!					|
for this type?				is reserved (i.e., your custom									|
					constructors must all have									|
					arguments).											|
																	|
When do variables of this		When they fall out of the defining 		When the object is garbage collected.		|
type die?				scope.												|
----------------------------------------------------------------------------------------------------------------------------------------

C# supports the concept of nullable data types. Simply put, a nullable type can represent all the values of its underlying type,
plus the value null. Thus, if you declare a nullable bool, it could be assigned a value from the set {true, false, null}.
This can be extremely helpful when working with the relational databases, given that it is quite common to encounter undefined columns
in database tables. Without the concept of a nullable data types, there is no convenient manner in C# to represent a numerical
data point with no value.
To define a nullable variable type, the question mark symbol (?) is suffixed to the inderlying data type. Do note that this syntax
is legal only when applied to value types. If you attempt to create a nullable reference type (including strings), you are issued
a compile-time error. Like a non-nullable variable, local nullable variables must be assigned an initial value before you can 
use them.

In C#, the ? suffix notation is a shorthand for creating an instance of the generic System.Nullable<T> structure type.
The System.Nullable<T> type provides a set of members that all nullable types can make use of.

The next aspect to be aware of is any variable that might have a null value (i.e., a reference-type variable or a nullable 
value-type variable) can make use of the C# ?? operator, which is formally termed the null coalescing operator. This operator
allows you to assign a value to a nullable type if the retrieved value is in fact null.

The benefit of using the ?? operator is that it provides a more compact version of a traditional if/else condition.

				PART III Object-Oriented Programming with C#

		Chapter 5 Understanding Encapsulation

As far as the .NET platform is concerned, the most fundamental programming construct is the class type. Formally, a class is a user-defined
type that is composed of field data (often called member variables) and members that operate on this data (such as constructors, properties,
methods, events, and so forth). Collectively, the set of field data represents the "state" of a class instance (otherwise known as an object).
The power of object-oriented languages, such as C#, is that by grouping data and related functionality in a unified class definition, 
you are able to model your software after entities in the real world.

Public members of a class are directly accessible once an object of this type has been created. Recall the term of object is used
to describe an instance of a given class type created using the new keyword.

Field data of a class should seldom (if ever) be defined as public. To preserve the integrity of your state data, it is a far better design
to define data as private (or possibly protected) and allow controlled access to the data via properties.

A constructor is a special method of a class that is called indirectly when creating an object using the new keyword.
However, unlike a "normal" method, constructors never have a return value (not even void) and are always named identically
to the class they are constructing.

Every C# class is provided with a "freebie" default constructor that you can redefine if need be. By definition, a default constructor
never takes arguments. After allocating the new object into memory, the default constructor ensures that all field data of the class is
set to an appropriate default value.

If you are not satisfied with these default assignments, you may redefine the default constructor to suit your needs.

Typically, classes define additional constructors beyond the default. In doing so, you provide the object user with a simple and
consistent way to initialize the state of an object directly at the time of creation.

When you define a method of the same name that differs by the number or type of arguments, you have overloaded the method.

C# supplies a this keyword that provides access to the current class instance. One possible use of the this keyword is to resolve scope ambiguity, which can arise
when an incoming parameter is named identically to a data field of the class.

Another using of the this keyword is to design a class using a technique termed constructor chaining. This desing pattern is helpful when you have a class that
defines multiple constructors. Given that constructors often validate the incoming arguments to enforce various business rules, it can be quite common to find
redundant validation logic within a class's constructor set.

A cleaner approach is to designate the constructor that takes the greatest number of arguments as the "master constructor" and have its implementation perform the
required validation logic. The remaining constructors can make use of the this keyword to forward the incoming arguments to the master constructor and provide
any additional parameters as necessary. In this way, you need to worry out only about maintaining a single constructor for the entire class, while the remaining
constructors are basically empty.

On a final note, do know that once a constructor passes arguments to the designated master constructor (and that constructor has processed the data),
the constructor invoked originally by the caller will finish executing any remaining code statements.

A C# class may define any number of static members, which are declared using the static keyword. When you do so, the member in question must be invoked
directly from the class level, rather than from an object reference variable.

Simply put, static members are items that are deemed (by the class designer) to be so common place that there is no need to create an instance of the class
before invoking the member. While any class can define static members, they are quite commonly found within utility classes. By definition,
a utility class is a class that does not maintain any object-level stats and is not created with the new keyword. Rather, a utility class exposes all functionality
as class-level (aka static) members.

The static keyword can be applied to the following:
- data of a class
- methods of a class
- properties of a class
- a constructor
- the entire class definition
- in conjunction with the C# using keyword

When you define static data of a class, the memory is shared by all objects of that category.

It is a compiler error for a static member to reference nonstatic members in its implementation. On a related note, it is an error to use the this keyword
on a static member because this implies an object!

Simply put, a static constructor is a special constructor that is an ideal place to initialize the values of static data when the value is not known
at compile time (e.g., you need to read in the value from an external file, read in the values from a database, generate a random, or whatnot).

Here are a few points of interest regarding static constructors:
- A given class may define only a single static constructor. In other words, the static constructor cannot be overloaded.
- A static constructor does not take an access modifier and cannot take any parameters
- A static constructor executes exactly one time, regardless of how many objects of the type are created
- The runtime invokes the static constructor when it creates an instance of the class or before accessing the first static member invoked by the caller
- The static constructor executes before any instance-level constructors

It is also possible to apply the static keyword directly on the class level. When a class has been defined as static, it is not creatable using the 
new keyword, and it can contain only members or data fields marked with the static keyword. If this is not the case, you receive compiler error.

It is now possible to define a C# using directive, which will import all static members into the declaring code.

All object-oriented languages must contend with three core principles, often called the pillars of object-oriented programming (OOP).

1) Encapsulation - how does this language hide an object's internal implementation details and preserve data integrity?
2) Inheritance - how does this language promote code reuse?
3) Polymorphism - how does this language let you treat related objects in a similar way?

A class's polymorphic interface is constructed using any number of virtual or abstract members.
In a nutshell, a virtual member is a member in a base class that defines a default implementation that may be changed (or more formally speaking, overriden)
by a derived class. In contrast, an abstract method is a member in a base class that does not provide a default implementation but does provide a signature.
When a class derives from a base class defining an abstract method, it must be overriden by a derived type. In either case, when derived types override
the members defined by a base class, they are essentially redefining how they respond to the same request.

C# Access Modifiers
----------------------------------------------------------------------------------------------------------------------------------------------------	
C# Access Modifier	May Be Applied To		Meaning in Life										    |
----------------------------------------------------------------------------------------------------------------------------------------------------|
public 			Types or type members		Public items have no access restrictions. A public member can be accessed from an object,   |
							as well as any derived class. A public type can be accessed from other external 	    |
							assemblies.										    |
private 		Type members or 		Private items can be accessed only by the class (or structure) that defines the item.	    |
			nested types														    |
protected		Type members or			Protected items can be used by the class that defines it and any child class. However,	    |
			nested types			protected items cannot be accessed from the outside world using C# dot operator.            |
internal		Types or type members		Internal items are accessible only within the current assembly. Therefore, if you define    |
							a set of internal types within a .NET class library, other assemblies 			    |
							are not able to use them.								    |
protected internal	Type members or			When the protected and internal keywords are combined on an item, the item is accessible    |
			nested types			within the defining assembly, within the defining class, and by derived classes.	    |
----------------------------------------------------------------------------------------------------------------------------------------------------

By default, type members are implicitly private while types are implicitly internal.

A nested type is a type declared directly within the scope of class or structure.

The concept of encapsulation revolves around the notion that an object's data should not be directly accessible from an object instance.
Rather, class data is defined as private. If the object user wants to alter the state of an object, it does so indirectly using public members.

You should get in the habit of defining private data, which is indirectly manipulated using one of two main techniques:

a) you can define a pair of public accessor (get) and mutator (set) methods
b) you can define a public .NET property

Although you can encapsulate a piece of field data using traditional get and set methods, .NET languages prefer to enforce 
data encapsulation state data using properties.

Within a set scope of a property, you can use a token named value, which is used to represent the incoming value used to assign the property by the caller.
This token is not a true C# keyword but is what is known as a contextual keyword. When the token value is within the set scope of the property, 
it always represent the value being assigned by the caller, and it will always be the same underlying data type as the property itself.

Properties, specifically the set portion of a property, are common places to package up the business rules of your class.

When encapsulating data, you might want to configure a read-only property. To do so, simply omit the set block. Likewise, 
if you want to have a write-only property, omit the get block.

To streamline the process of providing simple encapsulation of field data, you may use automatic property syntax.
When defining automatic properties, you simply specify the access modifier, underlying data type, property name, and empty get/set scopes.
At compile time, your type will be provided with an autogenerated private backing field and a fitting implementation of the get/set logic.
With the current version of C#, it is now possible to define a "read-only automatic property" by omitting the set scope. 
However, it is not possible to define a write-only property.

To help streamline the process of getting up and running, C# offers object initializer syntax. Using this technique, it is possible to create
a new object variable and assign a slew of properties and/or public fields in a few lines of code. Syntactically, an object initializer consists
of a comma-delimited list of specified values, enclosed by { and } tokens. Each member in the initialization list maps to the name of a public field
or public property of the object being initialized.

C# offers the const keyword to define constant data, which can never change after the initial assignment. As you might guess, this can be helpful
when you are defining a set of known values for use in your applications that are logically connected to a given class or structure.
The constant fields of a class are implicitly static. Regardless of where you define a constant piece of data, the one point to always
remember is that the initial value assigned to the constant must be specified at the time you define the constant. 
The reason for this restriction has to do with the fact the value of constant data must be known at compile time.
Constructors (or any other method), as you know, are invoked at runtime.

Closely related to constant data is the notion of read-only field data (which should not be confused with a read-only property).
Like a constant, a read-only field cannot be changed after the initial assignment. However, unlike a constant, the value assigned to a read-only field
can be determined at runtime and, therefore, can legaly be assigned within the scope of a constructor but nowhere else.
This can be helpful when you don't know the value of a field until runtime, perhaps because you need to read an external file to obtain the value,
but want to ensure that the value will not change after that point.
Unlike a constant field, read-only fields are not implicitly static. Thus, if you want to expose PI from the class level, you must explicitly
use the static keyword. If you know the value of a static read-only field at compile time, the initial assignment looks similar to that of a constant
(however, in this case, it would be easier to simply use the const keyword in the first place, as you are assigning the data field at the time of
declaration).

It is important to understand the role of the C# partial keyword. A production-level class could easily consist of hundreds and hundreds (if not thousands)
of lines of code within a single *.cs file. As it turns out, when you are creating your classes, it is often the case that much of the boilerplate code
can be basically ignored after it is accounted for. For example, field data, properties, and constructors tend to remain as is during production,
while methods tend to be modified quite often to account for updated algorithm and so forth.
In C#, you can partition a single class across multiple code files to isolate the boilerplate code from more readily useful (and complex) members.
Remember that every aspect of a partial class definition must be marked with the partial keyword!
The whole idea of a partial class is realized only during design time. After the application has been compiled, there is just a single, unified class
within the assembly. The only requirement when defining partial types is that the type's name is identical and defined within the same .NET namespace.

		Chapter 6 Understanding Inheritance and Polymorphism

Specifically speaking, code reuse comes in two flavors: inheritance (the "is-a" relationship) and the containment/delegation model (the "has-a") relationship.
When you establish "is-a" relantionship between classes, you are building a dependency between two or more class types. The basic idea behind classical
inheritance is that new classes can be created using existing classes as a starting point.

The existing class that will serve as the basis for the new class is termed a base class, superclass, or parent class. The role of a base class is to define
all the common data and members for the classes that extend it. The extending classes are formally termed derived or child classes. In C#, you make use
of the colon operator on the class definition to establish an "is-a" relantionship between classes. 

Although constructors are typically defined as public, a derived class never inherits the constructors of a parent class. 
Constructors are used to construct only the class that they are defined within.

Remember, private members can be accessed only by the class that defines it.

Speaking of base classes, it is important to keep in mind that C# demands that a given class have exactly one direct base class 
(the technique is known as multiple inheritance, or simple MI). It is not possible to create a class type that directly derives 
from two or more base classes. If you attempted to create a class that specifies two direct parent classes, you would receive compiler errors.

C# supplies another keyword, sealed, that prevents inheritance from occuring. When you mark a class as sealed, the compiler will not allow you
to derive from this type. Most often, sealing a class makes the best sense when you are designing a utility class.

C# structures are always implicitly sealed. Therefore, you can never derive one structure from another structure, a class from a structure,
or a structure from a class. Structures can be used to model only stand-alone, atomic, user-defined data types. If you want to leverage
the is-a relationship, you must use classes.

The base keyword is hanging off the constructor signature, which always indicates a derived constructor is passing data to the immediate parent constructor.
You may use the base keyword whenever a subclass wants to access a public or protected member defined by a parent class.
Finally, recall that once you add a custom constructor to a class definition, the default constructor is silently removed.

The benefit of defining protected members in a base class is that derived types no longer have to access the data indirectly using public methods or properties.
The possible downfall, of course, is that when a derived type has direct access to its parent's intenal data, it is possible to accidentally bypass existing
business rules found within public properties. When you define protected members, you are creating a level of trust between the parent class ad the child class,
as the compiler will not catch any violation of your type's business rules.
Although protected field data can break encapsulation, it is quite safe (and useful) to define protected methods. When building class hierarchies, 
it is common to define a set of methods that are only for use by derived types and are not intended for use by the outside world.

Recall that a sealed class cannot be extended by other classes. As mentioned, this technique is most often used when you are designing a utility class.

The "has-a" relationship is also known as the containment / delegation model or aggregation.

Exposing the functionality of the contained object to the outside world requires delegation.
Delegation is simply the act of adding public members to the containing class that use the contained object's functionality.

The following traits of nesting types are:
- nested types allow you to gain complete control over the access level of the inner type because they may be declared privately 
  (recall that non-nested classes cannot be declared using the private keyword)
- because a nested type is a member of the containing class, it can access private members of the containing class
- often, a nested type is useful only as helper for the outer class and is not intended for use by the outside world

Polymorphism provides a way for a subclass to define its own version of a method defined by its base class, using the process termed method overriding.
If a base class wants to define a method that may be (but does not have to be) overriden by a subclass, it must mark the method with the virtual keyword.
Methods that have been marked with the virtual keyword are termed virtual methods.
When a subclass wants to change the implementation details of a virtual method, it does so using the override keyword.

The sealed keyword can be applied to the method in order to prohibit override it.

You can use the abstract keyword in the class definition to create an abstract base class.
At first glance, it might seem strange to define a class that you cannot directly create an instance of. Recall, however, that base classes (abstract or not)
are useful, in that they contain all the common data and functionality of derived types. Also understand that although you cannot directly create an 
instance of an abstract class, it is still assembled in memory when derived classes are created. Thus, it is perfectly fine (and common) for abstract
classes to define any number of constructors that are called indirectly when derived classes are allocated.

When a class has been defined as an abstract base class (via the abstract keyword), it may define any number of abstract members. Abstract members can be used
whenever you want to define a member that does not supply a default implementation but must be accounted for by each derived class. By doing so, you enforce a
polymorphic interface on each descendant, leaving them to contend with the task of providing the details behind your abstract methods.
The usefulness of abstract methods becomes crystal clear when you once again remember that subclasses are never required to override virtual methods.
Abstract methods can be defined only in abstract classes. If you attempt to do otherwise, you will be issued a compiler error.
Methods marked with abstract are pure protocol. They simply define the name, return type (if any), and parameter set (if required).
Although it is not possible to directly create an instance of an abstract base class, you are able to freely store references to any subclass with 
an abstract base variable.

C# provides a facility that is the logical opposite of method overriding, termed shadowing. Formally speaking, if a derived class defines a member 
that is identical to a member defined in a base class, the derived class has shadowed the parent's version.
In the real world, the possibility of this occuring is the greatest when you are subclassing from a class you (or your team) did not create yourself
(such as when you purchase a third-party .NET software package).
You can include the new keyword to the method declaration. Doing so explicitly states that the derived type's implementation is intentionally designed
to effectively ignore the parent's version (again, in the real world, this can be helpful if external .NET software somehow conflicts with your current software).
You can also apply the new keyword to any member type inherited from a base class (field, constant, static member, or property).
Finally, be aware that it is possible to trigger the base class implementation of a shadowed member using an explicit cast.
 
The ultimate base class in the system is System.Object. Therefore, everything "is-an" Object and can be treated as such. Given this fact, it is legal
to store an instance of any type within an object variable.
The first law of casting between class types is that when two classes are related by an "is-a" relantionship, it is always safe to store a derived object
within a base class reference. Formally, this is called an implicit cast, as "it just works", given the laws of inheritance.
You can satisfy the compiler by performing an explicit cast. This is the second law of casting: you can, in such cases, explicitly downcast using 
the C# casting operator. The basic template to follow when performing an explicit cast looks something like the following: (ClassIWantToCastTo) referenceIHave

Be aware that explicit casting is evaluated at runtime, not compile time.
C# provides the as keyword to quickly determine at runtime whether a given type is compatible with another. When you use as keyword, you are able to determine
compatibility by checking against a null return value.
In addition to the as keyword, the C# language provides the is keyword to determine whether two items are compatible. Unlike the as keyword, however,
the is keyword returns false, rather than a null reference if the types are incompatible. In other words, the is keyword does not perform any sort of cast;
it just checks compatibility. If things are compatible, you can perform a safe cast.

In the .NET universe, every type ultimately derives from a base class named System.Object, which can be presented by the C# object keyword (lowercase o).
The Object class defines a set of common members for every type in the framework. In fact, when you do build a class that does not explicitly define its parent,
the compiler automatically derives your type from Object.
Like any class, System.Object defines a set of members.

public class Object
{
   // Virtual members
   public virtual bool Equals(object obj);
   protected virtual void Finalize();
   public virtual int GetHashCode();
   public virtual string ToString();

   // Instance-level, nonvirtual members.
   public Type GetType();
   protected object MemberwiseClone();
   
   // Static members.
   public static bool Equals(object objA, object objB);
   public static bool ReferenceEquals(object objA, object objB);
}

Core Members of System.Object
---------------------------------------------------------------------------------------------------------------------------------------------
Instance Method of		Meaning in Life												     |
Object Class																     |
---------------------------------------------------------------------------------------------------------------------------------------------
Equals()			By default, this method returns true only if the items being compared refer to the same item in memory.	     |
				Thus, Equals() is used to compare object references, not the state of the object. Typically, this method is  |	
				overriden to return true only if the objects being compared have the same internal state values		     |
				(that is, value-based semantics).									     |
				Be aware that if you override Equals(), you should also override GetHashCode(), as these methods are used    |
				internally by Hashtable types to retrieve subobjects from the container.				     |
				The ValueType class overrides this method for all structures, so they work with value-based comparisons.     |
GetHashCode()			This method returns an int that identifies a specific object instance.					     |
ToString()			This method returns a string representation of this object, using the <namespace>.<type name> format	     |
				(termed the fully qualified name). This method will often be overriden by a subclass to return a tokenized   |
				string or name/value pairs that represent the object's internal state, rather than its fully qualified name. |
GetType()			This method returns a Type object that fully describes the object you are currently referencing.	     |
---------------------------------------------------------------------------------------------------------------------------------------------

A hash code is a numerical value that represents an object as a particular state.
To be more specific, the System.Collections.Hashtable class calls GetHashCode() internally to gain a general idea where the object is located, 
but a subsequent (internal) call to Equals() determines the exact match.

		Chapter 7 Understanding Structured Exception Handling

Three commonly used anomaly-centric terms:
1) bugs - errors made by the programmer
2) user errors - are typically caused by the individual running your application
3) exceptions - are typically regarded as runtime anomalies that are difficult, if not impossible, to account for while programming the application

.NET structured exception handling is a technique for dealing with runtime exceptions.
Within the .NET nomenclature, an exception accounts for bugs, bugs user input, and runtime errors, even though programmers may view each of these
as a distinct issue.

Programming with structured exception handling involves the use of four interrelated entities:
- a class type that represents the details of the exception
- a member that throws an instance of the exception class to the caller under the correct circumstances
- a block of code on the caller's side that invokes the exception-prone member
- a block of code on the caller's side that will process (or catch) the exception, should it occur

The C# programming language offers five keywords (try, catch, throw, finally, and when) that allow you to throw and handle exceptions.
All exceptions ultimately derive from the System.Exception base class, which in turn derives from System.Object.
The Exception class implements two .NET interfaces. _Exception interface allows a .NET exception to be processed by an unmanaged code base 
(such as a COM application), while the ISerializable interface allows an exception object to be persisted across boundaries (such as a machine boundary).

Core Members of the System.Exception Type
------------------------------------------------------------------------------------------------------------------------------------------------
System.Exception Property			Meaning in Life											|
------------------------------------------------------------------------------------------------------------------------------------------------
Data					This read-only property retrieves a collection of key/value pairs 					|
					(represented by an object implemented IDictionary) that provide additional, 				|
					programmer-defined information about the exception. By default, this collection is empty.		|
HelpLink				This property gets or sets a URL to a help file or web site describing the error in full detail.	|
InnerException				This read-only property can be used to obtain information about the previous exception(s)		|
					that caused the current exception to occur. The previous exception(s) are recorded by passing		|
					them into the constructor of the most current exception.						|
Message					This read-only property returns the textual description of a given error. The error message itself	|
					is set as a constructor parameter.									|
Source					This property gets or sets the name of the assembly, or the object, that threw the current exception.	|
StackTrace				This read-only property contains a string that identifies the sequence of calls that triggered 		|
					the exception. As you might guess, this property is useful during debugging or if you want to dump	|
					the error to an external error log.									|
TargetSite				This read-only property returns a MethodBase object, which describes numerous details about the method  |
					that threw the exception (invoking ToString() will identify the method by name).			|
------------------------------------------------------------------------------------------------------------------------------------------------

When you are invoking a method that may throw an exception, you make use of a try/catch block. After you have caught the exception object,
you are able to invoke the members of the exception object to extract the details of the problem.

Exceptions that are thrown by the .NET platform are (appropriately) called system exceptions. These exceptions are generally regarded as nonrecoverable,
fatal errors. System exceptions derive directly from a base class named System.SystemException, which in turn derives from System.Exception
(which derives from System.Object).

By convention, all exception classes end with the Exception suffix; in fact, this is a .NET best practice.
As a rule, all custom exception classes should be defined as public classes (recall, the default access modifier of a non-nested type is internal).
The reason is that exceptions are often passes outside of assembly boundaries and should therefore be accessible to the calling code base.

If you want to build a truly prim-and-proper custom exception class, you would want to make sure your type adheres to .NET best practices:
1) derives from Exception/ApplicationException
2) is marked with the [System.Serializable] attribute
3) defines a default constuctor
4) defines a constructor that sets the inherited Message property
5) defines a constructor to handle "inner exceptions"
6) defines a constructor to handle the serialization of your type

In its simplest form, a try block has a single catch block. In reality, though, you often run into situations where the statements within a try block
could trigger numerous possible exceptions.

When you are authoring multiple catch blocks, you must be aware that when an exceptions is thrown, it will be processed by the first appropriate catch.
The rule of thumb to keep in mind is to make sure your catch blocks are structured such that the first catch is the most specific exception
(i.e., the most derived type in an exception-type inheritance chain), leaving the final catch for the most general (i.e., the base class of a given
exception inheritance chain).
Where at all possible, always favor catching specific exception classes, rather than a general System.Exception.
Remember, a final catch block that deals with System.Exception tends to be very general indeed.
C# also supports a "general" catch scope that does not explicitly receive the exception object thrown by a given member.

When you catch an exception, it is permissible for the logic in a try block to rethrow the exception up the call stack to the previous caller.
To do so, simply use the throw keyword within a catch block.
It is entirely possible to trigger an exception at the time you are handling another exception.

When you encounter an exception while processing another exception, best practice states that you should record the new exception object as an
"inner exception" within a new object of the same type as the initial exception.

A try/catch scope may also define an optional finally block. The purpose of a finally block is to ensure that a set of code statements will always execute,
exception (of any type) or not. When you need to dispose an object, close a file, or detach from a database (or whatever), a finally block ensures
a location for proper cleanup.

The current release of C# introduce a new (and completely optional) clause that can be placed on a catch scope, via the when keyword.
When you add this clause, you have the ability to ensure that the statements within a catch block are executed only if some condition in your code
holds true.

		Chapter 8 Working with Interfaces

An interface is nothing more than a named set of abstract members. The abstract methods are pure protocol in that they do not provide 
a default implementation. An interface expresses a behavior that a given class or structure may choose to support. A class or structure
can support as many interfaces as necessary.

By convention, .NET interfaces are prefixed with a capital letter I. 
When you are creating your own custom interfaces, it is considered a best practice to do the same.

When a class is marked as abstract, it may define any number of abstract members to provide polymorphic interface to all derived types.
However, even when a class does define a set of abstract members, it is also free to define any number of constructors, field data, 
nonabstract members (with implementation), and so on. 
Interfaces contain only member definitions.
The polymorphic interface established by an abstract parent class suffers from one major limitation in that only derived types support the members
defined by the abstract parent. C# does not support multiple inheritance for classes.

After an interface has been defined, it can be implemented by any class or structure, in any hierarchy, and within any namespace
or any assembly (written in any .NET programming language). Interface are highly polymorphic.

Another limitation of abstract base classes is that each derived type must contend with the set of abstract members and provide an implementation.

At a syntactic level, an interface is defined using the C# interface keyword.
Unlike a class, interfaces never specify a base class (not even System.Object). Moreover, the members of an interface never specify an access modifier
(as all interface members are implicitly public and abstract).

Remember that when you define interface members, you do not define an implementation scope for the members in question. Interfaces are pure protocol and,
therefore, never define an implementation (that is up to the supporting class or structure). Interface cannot have data fields, constructors,
and don't provide an implementation of members! However, .NET interface types are also able to define any number of property prototypes.
Interface types can also contain event and indexer definitions.
You can't allocate interface types as you would a class or structure.

When a class (or structure) chooses to extend its functionality by supporting interfaces, it does so using a comma-delimited list in the type definition.
Be aware that the direct base class must be the first item listed after the colon operator. When your class type derives directly from System.Object,
you are free to simply list the interface (or interfaces) supported by the class, as the C# compiler will extend your types from System.Object
if you do not say otherwise.

Understand that implementing an interface is an all-or-nothing proposition. The supporting types is not able to selectively choose which members it will
implement.

One way to determine at runtime whether a type supports a specific interface is to use an explicit cast. 
If the type does not support the requested interface, you receive an InvalidCastException.

You can determine whether a given type supports an interface by using the as keyword. If the object can be treated as the specified interface,
you are returned a reference to the interface in question. If not, you receive a null reference.

Notice that when you use the as keyword, you have no need to use try/catch logic, given that if the reference is not null,
you know you are calling on a valid interface reference.

You may also check for an implemented interface using the is keyword. If the object in question is not compatible with the specified interface,
you are returned the value false. On the other hand, if the type is compatible with the interface in question, you can safely call the members
without needing to use try/catch logic.

You may construct methods that take interfaces as parameters.

If you attempt to pass in a type not supporting the necessary interface, you receive a compile-time error.
Interfaces can also be used as method return values.
The same interface can be implemented by numerous types, even if they are not within the same class hierarchy and do not have a common parent class
beyond System.Object.

When you have an array of a given interface, the array can contain any class or structure that implements that interface.

When you implement several interfaces that have identical members, you can resolve this sort of name clash using explicit interface
implementation syntax.

When explicitly implementing an interface member, the general pattern breaks down to this:

returnType InterfaceName.MethodName(params){}

Note that when using this syntax, you do not supply an access modifier; explicitly implemented members are automatically private.

Interfaces can be arranged in an interface hierarchy. Like a class hierarchy, when an interface extends an existing interface, it inherits the 
abstract members defined by the parent (or parents). Of course, unlike class-based inheritance, derived interfaces never inherit true implementation.
Rather, a derived interface simply extends its own definition with additional abstract members.
Interface hierarchies can be useful when you want to extend the functionality of an existing interface without breaking existing code base.

The yield keyword is used to specify the value (or values) to be returned the caller's foreach construct. When the yield return statement is reached,
the current location in the container is stored, and execution is restarted from this location the next time the iterator is called.
It is also interesting to note that the yield keyword can technically be used within any method, regardless of its name. These methods (which are technically
called named iterators) are also unique in that they can take any number of arguments. When building a named iterator, be aware that the method
will return the IEnumerable interface, rather than the expected IEnumerator-compatible type.

So, to wrap up your look at building enumerable objects, remember that for your custom types to work with the C# foreach keyword, the container must define
a method named GetEnumerator(), which has been formalized by the IEnumerable interface type. The implementation of this method is typically achieved
by simply delegating it to the internal member that is holding onto the subobjects; however, it is also possible to use the yield return syntax to provide
multiple "named iterator" methods.

When you want to give your custom type the ability to return an identical copy of itself to the caller, you may implement the standard ICloneable interface.
This type defines a single method named Clone().

public interface ICloneable
{
	object Clone();
}

Obviously, the implementation of the Clone() method varies among your classes. However, the basic functionality tends to be the same: copy the values
of your member variables into a new object instance of the same type and return it to the user.

The System.IComparable interface specifies a behavior that allows an object to be sorted based on some specified key.

public interface IComparable
{
	int CompareTo(object o);
}

The generic version of this interface (IComparable<T>) provides a more type-safe manner to handle comparisons between objects.

CompareTo() Return Values
-----------------------------------------------------------------------------------------------------------
CompareTo() Return Value			Description						   |
-----------------------------------------------------------------------------------------------------------
Any number less than zero		This instance comes before the specified object in the sort order  |
Zero 					This instance is equal to the specified object 			   |
Any number greater than zero		This instance comes after the specified object in the sort order   |	
------------------------------------------------------------------------------------------------------------

The System.IComparer interface specifies a behavior that allows two objects to be sorted on some specified keys.

public interface IComparer
{
	int Compare(object o1, object o2);
}

The generic version of this interface (IComparer<T>) provides a more type-safe manner to handle comparisons between objects.
Unlike the IComparable interface, IComparer is typically not implemented on the type you are trying to sort. Rather, you implement this interface
on any number of helper classes, one for each sort order.

				PART IV Advanced C# Programming

		Chapter 9 Collections and Generics

The most primitive container you could use to hold application data is undoubtedly the array. C# arrays allow you to define a set of identically typed
items (including an array of System.Objects, which essentially represents an array of any type of data) of a fixed upper limit.
While basic arrays can be useful to manage small amounts of fixed-size data, there are many other times where you require a more flexible data structure,
such as a dynamically growing and shrinking container or a container that can hold objects that meet only a specific criteria (e.g., only objects deriving
from a specific base class or only objects implementing a particular interface). When you make use of a simple array, always remember they are "fixed size".
It is actually possible to change the size of an array using the generic Resize()<T> method. However, this will result in a copy of the data into a new 
array object and could be inefficient.
To help overcome the limitations of a simple array, the .NET base class libraries ship with a number of namespaces containing collection classes.
Unlike a simple C# array, collection classes are built to dynamically resize themselves on the fly as you insert or remove items. Moreover, many of the
collection classes offer increased type safety and are highly optimized to process the contained data in a memory-efficient manner.
A collection class can belong to one of two broad categories:

- Nongeneric collections (primarily found in the System.Collections namespace)
- Generic collections (primarily found in the System.Collections.Generic namespace)

Nongeneric collections are typically designed to operate on System.Object types and are, therefore, loosely typed containers (however, some nongeneric
collections do operate only on a specific data type of data, such as string objects). In contrast, generic collections are much more type safe, given that
you must specify the "type of type" they contain upon creation. The telltale sign of any generic item is the "type parameter" marked with angled brackets
(for example, List<T>).

Useful Types of System.Collections
-----------------------------------------------------------------------------------------------------------------------------------	   
System.Collections Class			Meaning in Life					Key Implemented Interfaces	   |
-----------------------------------------------------------------------------------------------------------------------------------|
ArrayList			Represents a dynamically sized collection of		IList, ICollection, IEnumerable,	   |
				objects listed in sequential order			ICloneable				   |
BitArray			Manages a compact array of bit values, which are	ICollection, IEnumerable, 		   |
				represented as Booleans, where true indicates		ICloneable				   |
				that the bit is on (1) and false indicates							   |
				the bit is off (0)										   |
Hashtable			Represents a collection of key-value pairs that are	IDictionary, ICollection, IEnumerable,	   |
				organized based on the hash code of the key		ICloneable				   |
Queue				Represents a standard first-in, first-out (FIFO)	ICollection, IEnumerable,		   |
				collection of objects					ICloneable				   |
SortedList			Represents a collection of key-value pairs that are	IDictionary, ICollection, IEnumerable,	   |
				sorted by the keys and are accessible by key and	ICloneable				   |
				by index											   |
Stack				A last-in, first-out (LIFO) stack providing push and 	ICollection, IEnumerable, and		   |
				pop (and peek) functionality				ICloneable				   |
-----------------------------------------------------------------------------------------------------------------------------------

Key Interfaces Supported by Classes of System.Collections
------------------------------------------------------------------------------------------------------------------------------------
System.Collections Interface				Meaning in Life								    |
------------------------------------------------------------------------------------------------------------------------------------|
ICollection				Defines general characteristics (e.g., size, enumeration, and thread safety) for all 	    |
					nongeneric collection types								    |
ICloneable				Allows the implementing object to return a copy of itself to the caller			    |
IDictionary				Allows a nongeneric collection object to represent its contents using key-value pairs	    |
IEnumerable				Returns an object implementing the IEnumerator interface				    |
IEnumerator				Enables foreach style iteration of collection items					    |
IList					Provides behavior to add, remove, and index items in a sequential list of objects	    |
------------------------------------------------------------------------------------------------------------------------------------

Boxing is a mechanism to store the data in a value type within a reference variable. Boxing can be formally defined as the process
of explicitly assigning a value type to a System.Object variable. When you box a value, the CLR allocates a new object on the heap
and copies the value type's value into that instance. What is returned to you is a reference to the newly allocated heap-based object.

The opposite operation is also permitted through unboxing. Unboxing is the process of converting the value held in the object
reference back into a corresponding value type on the stack. The CLR begins by verifying that the receiving data type is equivalent 
to the boxed type, and if so, it copies the value back into a local stack-based variable. You must unbox into an appropriate data type.
If you attempt to unbox a piece of data into the incorrect data type, an InvalidCastException exception will be thrown.

The boxing/unboxing process is quite helpful because it allows you to assume everything can be be treated as a System.Object, while the CLR
takes care of the memory-related details on your behalf.

Boxing and unboxing are convenient from a programmer's viewpoint, but this simplified approach to stack/heap memory transfer comes with the 
baggage of performance issues (in both speed of execution and code size) and a lack of type safety. To understand the performance issues,
ponder the steps that must occur to box and unbox a simple integer.
	1. A new object must be allocated on the managed heap
	2. The value of the stack-based data must be transfered into that memory location
	3. When unboxed, the value stored on the heap-based object must be transferred back to the stack
	4. The now unused object on the heap will (eventually) be garbage collected

However, there is another aspect of type safety you must keep in mind in a generic-free world: the fact that a majority of the classes of
System.Collections can typically hold anything whatsoever because their members are prototyped to operate on System.Objects.

Here is a short list of the benefits generic containers provide over their nongeneric counterparts:

	1. Generics provide better performance because they do not result in boxing or unboxing penalties when storing value types
	2. Generics are type safe because they can contain only the "type of type" you specify
	3. Generics greatly reduce the need to build custom collection types because you specify the "type of type" when creating
	   the generic container

Only classes, structures, interfaces, and delegates can be written generically; enum types cannot.

Typically T is used to represent types, TKey or K is used for keys, and TValue or V is used for values.

Key Interfaces Supported by Classes of System.Collections.Generic
------------------------------------------------------------------------------------------------------------
System.Collections.Generic Interface			Meaning in Life					    |
------------------------------------------------------------------------------------------------------------      
ICollection<T>					Defines general characteristics (e.g., size, enumeration,   |
						and thread safety) for all generic collection types	    |
IComparer<T>					Defines a way to compare to objects			    |
IDictionary<TKey, TValue>			Allows a generic collection object to represent its	    |
						contents using key-value pairs				    |
IEnumerable<T>					Returns the IEnumerator<T> interface for a given object     |
IEnumerator<T>					Enables foreach-style iteration over a generic collection   |
IList<T>					Provides behavior to add, remove, and index items in a 	    |
						sequential list of objects				    |
ISet<T>						Provides the base interface for the abstraction of sets	    |
------------------------------------------------------------------------------------------------------------

Classes of System.Collections.Generic
-------------------------------------------------------------------------------------------------------------
Generic Class				Supported Key Interfaces		Meaning in Life		     |
-------------------------------------------------------------------------------------------------------------
Dictionary<TKey, TValue>		ICollection<T>,			This represents a generic collection |	
					IDictionary<TKey, TValue>,	of keys and values 		     |
					IEnumerable<T>							     |
LinkedList<T>				ICollection<T>, 		This represents a double	     |
					IEnumerable<T>			linked list.			     |
List<T>					ICollection<T>,			This is a dynamically resizable	     |
					IEnumerable<T>, IList<T>	sequential list of items.	     |
Queue<T>				ICollection (nongeneric),	This is a generic implementation     |
					IEnumerable<T>			of a first-in, first-out (FIFO) list.|
SortedDictionary<TKey, TValue>		ICollection<T>,			This is a generic implementation     |
					IDictionary<TKey, TValue>,	of a sorted set of key-value pairs.  |
					IEnumerable<T>							     |
SortedSet<T>				ICollection<T>,			This represents a collection of	     |
					IEnumerable<T>, ISet<T>		objects that is maintained in sorted |
									order with no duplication.	     |
Stack<T>				ICollection (nongeneric),	This is a generic implementation     |
					IEnumerable<T>			of a last-in, first-out (LIFO) list. |
-------------------------------------------------------------------------------------------------------------

With the introduction of generics, the C# default keyword has been given a dual identity. In addition to its use within
a switch construct, it can also be used to set a type parameter to its default value. This is helpful because
a generic type does not know the actual placeholders up front, which means it cannot safety assume what 
the default value will be. The defaults for a type parameter are as follows:
- Numeric values have a default value of 0
- Reference types have a default value of null
- Fields of a structure are set to 0 (for value types) or null (for reference types)

The .NET platform allows you to use the where keyword to get extremely specific about what a given type parameter must look like.

Possible Constraints for Generic Type Parameter
------------------------------------------------------------------------------------------------------------------------
Generic Constraint				Meaning in Life								|
------------------------------------------------------------------------------------------------------------------------
where T : struct			The type parameter <T> must have System.ValueType in its chain			|
					of inheritance (i.e., <T> must be a structure).					|
where T : class				The type parameter <T> must not have System.ValueType in its chain		|
					of inheritance (i.e., <T> must be a reference type).				|
where T : new()				The type parameter <T> must have a default constructor.				|
					This is helpful if your generic type must create an instance of the type	|
					parameter because you cannot assume you know the format of custom		|
					constructors. Note that this constraint must be listed last on a 		|
					multiconstrained type.								|
where T : NameOfBaseClass		The type parameter <T> must be derived from the class specified by 		|
					NameOfBaseClass.								|
where T : NameOfInterface		The type parameter <T> must implement the interface specified by		|
					NameOfInterface. You can separate multiple interfaces as a			|
					comma-delimited list.								|
------------------------------------------------------------------------------------------------------------------------

		Chapter 10 Delegates, Events, and Lambda Expressions

In the .NET Framework, callbacks are accomplished in a type-safe and object-oriented manner using delegates. In essence,
a delegate is a type-safe object that points to another method (or possibly a list of methods) in the application, which can be
invoked at a later time. Specifically, a delegate maintains three important pieces of information:
- the address of the method on which it makes call
- the parameters (if any) of this method
- the return type (if any) of this method

.NET delegates can point to either static or instance methods. After a delegate object has been created and given the necessary
information, it may dynamically invoke the method(s) it points to at runtime. Every delegate in the .NET Framework
(including your custom delegates) is automatically endowed with the ability to call its methods, synchronously or
asynchronously. This fact greatly simplifies programming tasks, given that you can call a method on a secondary thread
of execution without creating and managing a Thread object.

When you want to create a delegate type in C#, you use the delegate keyword. The name of your delegate type can be
whatever you desire. However, you must define the delegate to match the signature of the method(s) it will point to.
When the C# compiler processes delegate types, it automatically generates a sealed class deriving 
from System.MulticastDelegate. This class (in conjunction with its base class, System.Delegate) provides the necessary
infrastructure for the delegate to hold onto a list of methods to be invoked at a later time.

The delegate defines three public methods during the run-time. Invoke() is perhaps the key method, as it is used to invoke
each method maintained by the delegate object in a synchronous manner, meaning the caller must wait for the call
to complete before continuing on its way. 
BeginInvoke() and EndInvoke() provide the ability to call the current method asynchronously on a separate thread of execution.
The most common reasons developers create secondary threads of execution is to invoke methods that require time to complete.

C# delegate type definition results in a sealed class with three compiler-generated methods whose parameter and return types
are based on the delegate's declaration.

Select Members of System.MulticastDelegate/System.Delegate
--------------------------------------------------------------------------------------------------------------------------------
Member						Meaning in Life									|
--------------------------------------------------------------------------------------------------------------------------------
Method					This property returns a System.Reflection.MethodInfo object that represents		|
					details of a static method maintained by the delegate.					|
Target					If the method to be called is defined at the object level				|
					(rather than a static method), Target returns an object that represents			|
					the method maintained by the delegate. If the value returned from Target equals null,	|
					the method to be called is a static member.						|
Combine()				This static method adds a method to the list maintained by the delegate.		|
					In C#, you trigger this method using the overloaded += operator as a shorthand		|
					notation.										|
GetInvokationList()			This method returns an array of System.Delegate objects, each representing a particular	|
					method that may be invoked.								|
Remove() RemoveAll() 			These static methods remove a method (or all methods) from the delegate's invocation 	|
					list. In C#, Remove() method can be called indirectly using 				|
					the overloaded -= operator.								|
--------------------------------------------------------------------------------------------------------------------------------
					
Strictly speaking, you could have define your delegate member variable as public, therefore avoiding the need to create additional
registration methods. However, by defining the delegate member variable as private, you are enforcing encapsulation services
and providing a more type-safe solution.

When you use the += operator on a delegate object, the compiler resolves this to a call on the static Delegate.Combine() method.

C# provides a shortcut termed method group conversion. This feature allows you to supply a direct method name, 
rather than a delegate object, when calling methods that take delegates as arguments.

In many cases, you simply want "some delegates" that takes a set of arguments and possibly has a return value other than void.
In these cases, you can use the framework's built-in Action<> and Func<> delegate types.

You can use the generic Action<> delegate to "point to" a method that takes up to 16 arguments (that ought to be enough!)
and returns void. Now recall, because Action<> is a generic delegate, you will need to specify the underlying types of 
each parameter as well.

The generic Func<> delegate can point to methods that (like Action<>) take up to 16 parameters and a custom return value.
The final type parameter is always the return value of the method.

Delegates are fairly interesting constructs in that way they enable objects in memory to engage in a two-way conversation.
However, working with the delegates in the raw can entail the creation of some boilerplate code (defining the delegate,
declaring necessary member variables, and creating custom registration and unregistration methods to preserve
encapsulation, etc.).
Moreover, when you use delegates in the raw as your application's callback mechanism, if you do not define a class's
delegate member variables as private, the caller will have direct access to the delegate objects. In this case,
the caller could reassign the variable to a new delegate object (effectively deleting the current list of fuctions
to call), and, worse yet, the caller would be able to directly invoke the delegate's invocation list.

As a shortcut, so you don't have to build custom methods to add or remove methods to a delegate's invocation list,
C# provides the event keyword. When the compiler process the event keyword, you are automatically provided with the
registration and unregistration methods, as well as any necessary member variables for your delegate types. 
These delegate member variables are always declared private, and, therefore, they are not directly exposed from the 
object firing the event. To be sure, the event keyword can be used to simplify how a custom class sends out 
notification to external objects.
Defining event is a two-step process. First, you need to define a delegate type (or reuse an existing one) that
will hold the list of methods to be called when the event is fired. Next, you declare an event
(using the C# event keyword) in terms of the related delegate type.

When the compiler processes the C# event keyword, it generates two hidden methods, one having an add_ prefix and
the other having a remove_ prefix. Each prefix is followed by the name of the C# event.

C# events also simplify the act of registering the caller-side event handlers. Rather than having to specify
custom helper methods, the caller simplify uses the += and -= operations directly (which triggers the 
correctly add_XXX() or remove_XXX() method in the background).

Before you fire an event to any listener, you make sure to check for null. This is important given that
if nobody is listening for your event but you fire it anyway, you will receive a null reference exception
at runtime.
Thankfully, with the current release of C#, you can leverage the null conditional operator (?) which essentially
performs this sort of check automatically. Be aware, when using this new simplified syntax, you must manually
call the Invoke() method of the underlying delegate.

As you begin to explore the events sent by a given type in the base class libraries, you will find that the first
parameter of the underlying delegate is a System.Object, while the second parameter is a descendant of 
System.EventArgs.

It is possible to associate an event directly to a block of code statements at the time of event registration.
Formally, such code is termed an anonymous method. The final curly bracket of an anonymous method must be
terminated by a semicolon. If you fail to do so, you are issued a compilation error.

SomeType t = new SomeType();
t.SomeEvent += delegate(optionallySpecifiedDelegateArgs){/* statements */};

Anonymous methods are interesting in that they are able to access the local variables of the method that
defines them. Formally speaking, such variables are termed outer variables of the anonymous method.
A few important points about the interaction between an anonymous method scope and the scope of the 
defining method should be mentioned:
- an anonymous method cannot access ref or out parameters of the defining method
- an anonymous method cannnot have a local variable with the same name as a local variable in the outer method
- an anonymous method can access instance variables (or static varibles, as appropriate) in the outer class scope
- an anonymous method can declare local variables with the same name as outer class member variables 
(the local variables have a distinct scope and hide the outer class member variables)

C# supports the ability to handle events "inline" by assigning a block of code statements directly to an event
using anonymous methods, rather than building a stand-alone method to be called by the underlying delegate.
Lambda expression are nothing more than a concise way to author anonymous methods and ultimately simplify
how you work with the .NET delegate type.

The lambda expressions can be used anywhere you would have used an anonymous method or a strongly typed
delegate. A lambda expression is written first defining a parameter list, followed be the => token
(C#'s token for the lambda operator found in the lambda calculus), followed by a set of statement
(or a single statement) that will process these arguments. From a high level, a lambda expression 
can be understood as follows:

ArgumentsToProcess => StatementsToProcessThem

		Chapter 11 Advanced C# Language Features

C# language provides the capability to design custom classes and structures that may be indexed just like a
standard array, by defining an indexer method. This particular feature is most useful when you are creating
custom collection classes (generic or nongeneric).

Indexers allow you to manipulate the internal collection of subobjects like a standard array. An indexer
is represented as a slightly modified C# property definition. In a simplest form, an indexer is created
using the this[] syntax. Apart from using the this keyword, the indexer look just like any other C# property
declaration.

Understand that indexer methods may be overloaded on a single class or structure. Thus, if it makes sense
to allow the caller to access subitems using a numerical index or a string value, you might define 
multiple indexers for a single type.

Overloadability of C# Operators
----------------------------------------------------------------------------------------------------------
C# Operator					Overloadability						  |
----------------------------------------------------------------------------------------------------------
+,-,!,~,++,--,true,false		These unary operators can be overloaded.			  |
+,-,*,/,%,&,|,^,<<,>>			These binary operators can be overloaded.			  |
==,!=,<,>,<=,>=				These comparison operators can be overloaded. C# demands that	  |
					"like" operators (i.e., <= and >=, == and !=) are overloaded	  |
					together.							  |
[]					The [] operator cannot be overloaded. However, the indexer	  |
					construct provides the same functionality.			  |
()					The () operator cannot be overloaded. However, custom conversion  |
					methods provide the same functionality.				  |
+=,-=,*=,/=,%=,&=,|=,^=,		Shorthand assignment operators cannot be overloaded; however,	  |
<<=,>>=					you receive them as a freebie when you overload the related	  |
					binary operator.						  |
----------------------------------------------------------------------------------------------------------

To equip a custom type to respond uniquely to intrinsic operators, C# provides the operator keyword,
which you can use only in conjunction with the static keyword. When you overload a binary operator
(such as + and -), you will most often pass in two arguments that are the same type as the defining class.

C# also allows you to overload various unary operators, such as ++ and --. When you overload a unary operator,
you also must use the static keyword with the operator keyword; however, in this case you simply pass in a
single parameter that is the same type as the defining class/structure.

C# provides two keywords, explicit and implicit, that you can use to control how your types respong during
an attempted conversion.

The structure constructor should be chained to the default constructor. The reason is that if you have a 
structure, which makes use of automatic property syntax, the default constructor must be explicitly called
(from all custom constructors) to initialize the private backing fields (for example, if the structure
had any additional fields/properties, this default contructor would initialize these fields to default
values). Yes, this is a quirky rules of C#, but after all, this is an advanced topics chapter.

Like the process of overloading an operator, conversion routines make use of the C# operator keyword,
in conjunction with the explicit or implicit keyword, and must be defined as static.
The incoming parameter is the entity you are converting from, while the operator type is the entity
you are converting to.

It is illegal to define explicit and implicit conversion functions on the same type if they do not differ
by their return type or parameter set. This might seem like a limitation; however, the second catch is that
when a type defines an implicit conversion routine, it is legal for the caller to make use of the explicit
cast syntax!

.NET 3.5 introduced the concept of extension methods, which allow you to add new methods or properties to
a class or structure, without modifying the original type in any direct manner.

When you define extension methods, the first restriction is that they must be defined within a static class
and, therefore, each extension method must be declared within the static keyword. The second point is that
all extension methods are marked as such by using this keyword as modifier on the first (and only the first)
parameter of the method in question. The "list qualified" parameter represents the item being
extended.

The reflection allows you to discover the structure of assemblies, types, and type members at runtime.
Understand that a given extension method can have multiple parameters, but only the first parameter can be
qualified with this. The additional parameters would be treated as normal incoming parameters for use
by the method.  In effect, although it can appear on the surface that extension methods are global in nature,
they are in fact limited to the namespaces that define them or the namespaces that import them.

It is common practice to not only isolate extension methods into a dedicated .NET namespace but into a 
dedicated class library. In this way, new applications can "opt in" to extensions by explicitly
referencing the correct library and importing the namespace.

It is also possible to define an extension method that can only extend a class or structure that
implements the correct interface.

Remember that this particular language feature can be useful whenever you want to extend the
functionality of a type but do not want to subclass (or cannot subclass if the type is sealed), for the
purposes of polymorphism.

You would never want to abandon the use of strongly typed classes/structures simply for the sake of doing so,
given anonymous types numerous limitations, which include the following:
- you don't control the name of the anonymous type
- anonymous types always extend System.Object
- the fields and properties of an anonymous type are always read-only
- anonymous types cannot support events, custom methods, custom operators, or custom overrides
- anonymous types are always implicitly sealed
- anonymous types are always created using the default constructor

However, when programming with the LINQ technology set, you will find that in many cases this syntax can be
helpful when you want to quickly model the overall shape of an entity rather than its functionality.

.NET platform defines two major categories of data: value types and reference types. Truth be told, however,
there is a third category: pointer types. To work with pointer types, you get a specific operators and
keywords that allow you to bypass the CLR's memomy-management scheme and take matters into your own hands.

Pointer-Centric C# Operators and Keywords
----------------------------------------------------------------------------------------------------------------
Operator/Keyword				Meaning in Life							|
----------------------------------------------------------------------------------------------------------------
* 					This operator is used to create a pointer variable (i.e., a variable 	|
					that represents a direct location in memory). As in C++, this same	|
					operator is used for pointer indirection.				|
&					This operator is used to obtain the address of a variable in memory.	|
->					This operator is used to access fields of a type that is		|
					represented by a pointer (the unsafe version of the C# dot operator).	|
[]					This operator (in an unsafe context) allows you to index the slot	|
					pointed to by a pointer variable (if you're a C++ programmer, you	|
					will recall the interplay between a pointer variable and the 		|
					[] operator).								|
++,--					In an unsafe context, the increment and decrement operators can		|
					be applied to pointer types.						|
+,-					In an unsafe context, the addition and subtraction operators can be 	|
					applied to pointer types.						|
==,!=,<,>,<=,=>				In an unsafe context, the comparison and equality operators can be	|
					applied to pointer types.						|
stackalloc				In an unsafe context, the stackalloc keyword can be used to allocate	|
					C# arrays directly on the stack.					|
fixed					In an unsafe context, the fixed keyword can be used to temporarily fix	|
					a variable so that its address can be found.				|
----------------------------------------------------------------------------------------------------------------

When you want to work with pointers in C#, you must specifically declare a block of "unsafe code" using 
the unsafe keyword (any code that is not marked with the unsafe keyword is considered "safe"
automatically).

The final unsafe-centric C# keyword to consider is sizeof. As in C++, the C# sizeof keyword is used to obtain
the size in bytes of an intrinsic data type, but not a custom type, unless within an unsafe context.

		Chapter 12 LINQ to Objects

The Language Integrated Query (LINQ) technology set, introduced initially in .NET 3.5, provides a concise,
symmetrical, and strongly typed manner to access a wide variety of data stores.

The key C# programming constructs that enable LINQ:
- implicitly typed local variable
- object/collection initialization syntax
- lambda expressions
- extension methods
- anonymous types

From a high level, LINQ can be understood as a strongly typed query language, embedded directly into the grammar of C#.
Using LINQ, you can build any number of expressions that have a look and feel similar to that of a database SQL query.
However, a LINQ query can be applied to any number of data stores, including stores that have nothing to do with
a literal relational database.
Although LINQ queries look similar to SQL queries, the syntax is not identical. In fact, many LINQ queries seem
to be the exact opposite format of a similar database query! If you attempt to map LINQ directly to SQL,
you will surely become frustrated. To keep your sanity, I recommend you try your best to regard LINQ queries
as unique statements, which just "happen to look" similar to SQL.

The LINQ API is an attempt to provide a consistent, symmetrical manner in which programmers can obtain and manipulate
"data" in the broad sense of the term. Using LINQ, you are able to create directly within the C# programming language
constructs called query expressions. These query expressions are based on numerous query operators that have been
intentionally designed to look and feel similar (but not quite identical) to a SQL expression.

Strictly speaking, "LINQ" is the term used to describe the overall approach to data access:
- LINQ to Object - this term refers to the act of applying LINQ queries to arrays and collections
- LINQ to XML - this term refers to the act of using LINQ to manipulate and query XML documents
- LINQ to DataSet - this term refers to the act of applying LINQ queries to ADO.NET Dataset objects
- LINQ to Entities - this aspect of LINQ allows you to make use of LINQ queries within ADO.NET Entity Framework (EF) API
- Parallel LINQ (aka PLINQ) - this allows for parallel processing of data returned from a LINQ query

It is also important to point out that a LINQ query expression (unlike a traditional SQL statement) is strongly typed.

Core LINQ-Centric Assemblies
-----------------------------------------------------------------------------------------------------------------------------
Assembly							Meaning in Life						     |
----------------------------------------------------------------------------------------------------------------------------- 
System.Core.dll						Defines the types that represents the core LINQ API.		     |
							This is the one assembly you must have access to if you want	     |
							to use any LINQ API, including LINQ to Objects.			     |
System.Data.DataSetExtensions.dll			Defines a handful of types to integrate ADO.NET types into	     |
							the LINQ programming paradigm (LINQ to DataSet).		     |
System.Xml.Linq.dll					Provides functionality for using LINQ with XML document		     |
							data (LINQ to XML).						     |
-----------------------------------------------------------------------------------------------------------------------------

Another important point regarding LINQ query expressions is that they are not actually evaluated until you iterate over the
sequence. Formally speaking, this is termed deferred execution. The benefit of this approach is that you are able to apply
the same LINQ query multiple times to the same container and rest assured you are obtaining the latest and greatest results.

When you need to evaluate a LINQ expression from outside the confines of foreach logic, you are able to call any number
of extension methods defined by the Enumerable type such as ToArray<T>(), ToDictionary<TSource, TKey>(), and ToList<T>().
These methods will cause a LINQ query to execute at the exact moment you call them, to obtain a snapshot of the data.
The usefulness of immediate execution is obvious when you need yo return the results of a LINQ query to an external caller.

It is possible to define a field within a class (or structure) whose value is the result of a LINQ query.
To do so, however, you cannot make use of implicit target (as the var keyword cannot be used for fields), and the target
of the LINQ query cannot be intstance-level data; therefore, it must be static.

Applying a LINQ query to a generic container is no different from doing so with a simple array, as LINQ to Objects
can be used on any item implementing IEnumerable<T>.

Recall that the query operations of LINQ are designed to work with any type implementing IEnumerable<T> (either directly
or via extension methods). Given that System.Array has been provided with such necessary infrastructure, it might surprise
you that the legacy (nongeneric) containers within System.Collections have not. Thankfully, it is still possible to iterate
over data contained within nongeneric collections using the generic Enumerable.OfType<T>() extension method.
When calling OfType<T>() from a nongeneric collection object (such as the ArrayList), simply specify the type of item within
the container to extract a compatible IEnumerable<T> object. In code, you can store this data point using an implicitly
typed variable.

As you know, nongeneric types are capable of containing any combinations of items, as the members of these containers
(again, such as ArrayList) are prototypes to receive System.Objects.

Common LINQ Query Operators
-----------------------------------------------------------------------------------------------------------------------------
Query Operators							Meaning in Life						     |
-----------------------------------------------------------------------------------------------------------------------------
from, in						Used to define the backbone for any LINQ expression, which allows    |
							you to extract a subset of data from a fitting container.	     |
where							Used to define a restriction for which items to extract from	     |
							a container.							     |
select							Used to select a sequence from the container.			     |
join, on, equals, into					Performs joins based on specified key. Remember, these "joins"	     |
							do not need to have anything to do with data in a		     |
							relational database.						     |
orderby, ascending, descending				Allows the resulting subset to be ordered in ascending or	     |
							descending order.						     |
group, by						Yields a subset with data grouped by a specified value.		     |
-----------------------------------------------------------------------------------------------------------------------------

The syntactical correctness of a LINQ query expression is validated at compile time, and you need to remember that the ordering
of these operators is critical. In the simplest terms, every LINQ query expression is build using the from, in, and select
operators. Here is the general template to follow:

var result = from matchingItem in container select matchingItem;

The item after the from operator represents an item that matches the LINQ query criteria, which can be named anything you choose.
The item after the in operator represents the data container to search (an array, collection, XML document, etc.).

To obtain a specific subset from a container, you can use the where operator. When doing so, the general template now becomes
the following code:

var result = from item in container where BooleanExpression select item;

Notice that the where operator expects an expression that resolves to a Boolean.

When you need to return projected data to a caller, one approach is to transform the query result into a .NET System.Array
object using the ToArray() extension method. Note that you must use a literal System.Array object and cannot make use
of the C# array declaration syntax, given that you don't know the underlying type of type because you are operating 
on a compiler-generated anonymous class!
When you need to return a LINQ result set that is the result of a project operation, transformation the data into an
Array type (or another suitable container via other members of the Enumerable type) is mandatory.

When you are projecting new batches of data, you may need to discover exactly how many items have been returned into the 
sequence. Any time you need to determine the number of items returned from a LINQ expression, simply use the Count()
extension method of the Enumerable class.
You can reverse the items within a result set quite simply using the Reverse<>() extension method of the Enumerable class.
A query expression can take an orderby operator to sort items in the subset by a specific value. By default, the order
will be ascending; thus, ordering by a string would be alphabetical, ordering by numerical data would be lowest to highest,
and so forth. If you need to view the results in a descending order, simply include the descending operator.

The Enumerable class supports a set of extension methods that allows you to use two (or more) LINQ queries as the basis
to find unions, differences, concatenations, and intersections of data. 
First, consider the Except() extension method, which will return a LINQ result set that contains the difference 
between two containers. 
The Intersect() method will return a result set that contains the common data items in a set of containers.
The Union() method returns a result set that includes all members of a batch of LINQ queries. You will not find repeating
values if a common member appears more than once.
The Concat() extension method returns a result set that is a direct concatenation of LINQ result sets.
When you call the Concat() extension method, you could very well end up with redundant entries in the fetched result,
which could be exactly what you want in some cases. However, in other cases, you might want to remove duplicate entries
in your data. To do so, simply call the Distinct() extension method.

LINQ queries can also be designed to perform various aggregation operations on the result set. The Count() extension
method is one such aggregation example. Other possibilities include obtaining an average, maximum, minimum, or sum
of values using the Max(), Min(), Average(), or Sum() members of the Enumerable class.

Keep the following points in mind regarding how LINQ query expressions are represented under the covers:
- Query expressions are created using various C# query operators.
- Query operators are simply shorthand notations for invoking extension methods defined by the System.Linq.Enumerable type.
- Many methods of Enumerable require delegates (Func<> in particular) as parameters.
- Any method requiring a delegate parameter can instead be passed a lambda expression.
- Lambda expressions are simply anonymous methods in disguise (which greatly improve readability).
- Anonymous methods are shorthand notations for allocating a raw delegate and manually building a delegate target method.

		Chapter 13 Understanding Object Lifetime	

A class is nothing more than a blueprint that describes how an instance of this type will look and feel in memory. Classes, of
course, are defined within a code file (which in C# takes a *.cs extension by convention).
After a class has been defined, you may allocate any number of objects using the C# new keyword. Understand, however, that the
new keyword returns a reference to the object on the heap, not the actual object. If you declare the reference variable as
a local variable in a method scope, it is stored on the stack for further use in your application. When you want to invoke
members on the object, apply the C# dot operator to the stored reference.

The structures are value types that are always allocated directly on the stack and are never placed on the .NET managed heap.
Heap allocation occurs only when you are creating instances of classes.

When you are building your C# application, you are correct to assume that the .NET runtime environment (aka the CLR) will
take care of the managed heap without your direct intervention. In fact, the golden rule of .NET memory management is
simple. Allocate a class instance onto the managed heap using the new keyword and forget about it. Once instantiated, 
the garbage collector will destroy an object when it is no longer needed. The next obvious question, of course, is, 
"How does the garbage collector determine when an object is no longer needed?" The short (i.e., incomplete) answer is that
the garbage collector removes an object from the heap only if it is unreachable by any part of your code base.

In fact, tracking down memory leaks is one of the most time-consuming (and tedious) aspects of programming in unmanaged
environments. By allowing the garbage collector to take charge of destroying objects, the burden of memory management has
been lifted from your shoulders and placed onto those of the CLR.

First, understand that the managed heap is more than just a random chunk of memory accessed by the CLR.
The .NET garbage collector is quite a tidy housekeeper of the heap, given that it will compact empty blocks of memory
(when necessary) for the purposes of optimization.
To aid in this endeavor, the managed heap maintains a pointer (commonly referred to as the next object pointer or new object
pointer) that identifies exactly where the next object will be located. That said, the newobj instruction tells the CLR
to perform the following core operations:
1) Calculate the total amount of memory required for the object to be allocated (including the memory required by the data 
members and the base classes).
2) Examine the managed heap to ensure that there is indeed enough room to host the object to be allocated. If there is, 
the specified constructor is called, and the caller is ultimately returned a reference to the new object in memory,
whose address just happens to be identical to the last position of the next object pointer.
3) Finally, before returning the reference to the caller, advance the next object pointer to point to the next available
slot on the managed heap.

When processing the newobj instruction, if the CLR determines that the managed heap does not have sufficient memory to 
allocate the requested type, it will perform a garbage collection in an attempt to free up memory. Thus, the next rule 
of garbage collection is also quite simple. If the managed heap does not have sufficient memory to allocate the requested
object, a garbage collection will occur.

When you assign object reference to null, the compiler generates CIL code that ensures the reference no longer points
to any object. What you must understand, however, is that assigning a reference to null does not in any way force the 
garbage collector to fire up at that exact moment and remove the object from the heap. The only thing you have 
accomplished is explicitly clipping the connection between the reference and the object it previously pointed to.
Given this point, setting reference to null under C# is far less consequential that doing so in other C-based
languages; however, doing so will certainly not cause any harm.

An application root (or simply root) is a storage location containing a reference to an object on the managed heap.
Strictly speaking, a root can fall into any of the following categories:
- references to global objects (though these are not allowed in C#, CIL code does permit allocation of global objects)
- references to any static objects/static fields
- references to local objects within an application's code base
- references to object parameters passed into a method
- references to objects waiting to be finalized
- any CPU register that references an object

During a garbage collection process, the runtime will investigate objects on the managed heap to determine whether they 
are still reachable (i.e., rooted) by the application. To do so, the CLR will build an object graph, which represents
each reachable object on the heap. The garbage collector will never graph the same object twice.

Strictly speaking, the garbage collector uses two distinct heaps, one of which is specifically used to store large objects.
This heap is less frequently consulted during the collection cycle, given possible performance penalties involved with
relocation large objects. Regardless, it is safe to consider the managed heap as a single region of memory.

When the CLR is attempting to locate unreachable objects, it does not literally examine every object places on the 
managed heap. Doing so, obviously, would involve considerable time, especially in larger (i.e., real-world)
applications.
To help organize the process, each object on the heap is assigned to a specific "generation". The idea behind generations
is simple: the longer an object has existed on the heap, the more likely it is to stay there. For example, the class
that defined the main window of a desktop application will be in memory until the program terminates. Conversely, objects
that have only recently been placed on the heap (such as an object allocated within a method scope) are likely to be
unreachable rather quickly. Given these assumptions, each object on the heap belongs to one of the following generations:
- Generation 0 - identifies a newly allocated object that has never been marked for collection
- Generation 1 - identifies an object that has survived a garbage collection (i.e., it was marked for collection but was
  removed because the sufficient heap space was acquired)
- Generation 2 - identifies an object that has survived more that one sweep of the garbage collector	

If all generation 0 objects have been evaluated but additional memory is still required, generation 1 objects are then
investigated for reachability and collected accordingly. Surviving generation 1 objects are then promoted to generation 2.
If the garbage collector still requires additional memory, generation 2 objects are evaluated. At this point, if a 
generation 2 object survives a garbage collection, it remains a generation 2 object, given the predefined upper limit
of object generations.
The bottom line is that by assigning a generation value to objects on the heap, newer objects (such as a local variables)
will be removed quickly, while older objects (such as a program's main window) are not "bothered" as often.

Prior to .NET 4.0, the runtime would clean up unused objects using a technique termed concurrent garbage collection.
Under this model, when a collection takes place for any generation 0 or generation 1 objects (recall these are 
ephemeral generations), the garbage collector temporarily suspends all active threads within the current process to ensure
that the application does not access the managed heap during the collection process.
Moreover, concurrent garbage collection allowed your program to continue allocating objects on the heap during the
collection of nonephemeral generations.

Beginning with .NET 4.0, the garbage collector is able to deal with thread suspension when it cleans up objects on the 
managed heap, using background garbage collection. Despite its name, this does not mean that all garbage collection now
takes place on additional background threads of execution. Rather, if a background garbage collection is taking place
for objects living in a nonephemeral generation, the .NET runtime is now able to collect objects on the ephemeral
generations using a dedicated background thread.
The .NET 4.0 and higher garbage collection has been improved to further reduce the amount of time a given thread involved
with garbage collection details must be suspended. The end result of these changes is that the process of cleaning up
unused objects living in generation 0 or generation 1 has been optimized and can result in better runtime performance of 
your programs (which is really important for real-time systems that require small, and predictable, GC stop time).

The mscorlib.dll assembly provides a class type named System.GC that allows you to programmatically interact with the 
garbage collector using a set of static members. Now, do be aware that you will seldom (if ever) need to make use of this 
class directly in your code. Typically, the only time you will use the members of System.GC is when you are creating 
classes that make internal use of unmanaged resources (call into the Windows C-based API, COM interop logic, etc.).

Select Members of the System.GC Type
--------------------------------------------------------------------------------------------------------------------------------										
System.GC Member							Description						|
--------------------------------------------------------------------------------------------------------------------------------
AddMemoryPressure()					Allows you to specify a numerical value that represents the calling	|
RemoveMemoryPressure()					object's "urgency level" regarding the garbage collection process.	|
							Be aware that these methods should alter pressure in tandem, and,	|
							thus, never remove more pressure that the total amount you		|
							have added.								|
Collect()						Forces the GC to perform a garbage collection. This method has been	|
							overloaded to specify a generation to collect, as well as the mode	|
							of collection (via the GCCollecionMode enumeration).			|
CollectionCount()					Returns a numerical value representing how many times a given		|
							generation has been swept.						|
GetGeneration()						Returns the generation to which an object currently belongs.		|
GetTotalMemory()					Returns the estimated amount of memory (in bytes) currently		|
							allocated on the managed heap. A Boolean parameter specifies		|
							whether the call should wait for garbage collection to occur before	|
							returning.								|
MaxGeneration						Returns the maximum number of generations supported on the target	|
							system. Under Microsoft's .NET 4.0, there are three possible		|
							generations: 0, 1, and 2.						|
SuppressFinalize()					Set a flag indicating that the specified object should not have		|
							its Finalize() method called.						|
WaitForPendingFinalizers()				Suspends the current thread until all finalizable objects have been	|
							finalized. This method is typically called directly after		|
							invoking GC.Collect().							|
--------------------------------------------------------------------------------------------------------------------------------
						
In some rare circumstances, it may be beneficial to programmatically force a garbage collection using GC.Collect().
Here are two common situations where you might consider interacting with the collection process:
- your application is about to enter into a block of code that you don't want interrupted by a possible garbage collection
- your application has just finished allocating an extremely large number of objects and you want to remove as much 
of the acquired memory as soon as possible

When you manually force a garbage collection, you should always make a call to GC.WaitForPendingFinalizers().
With this approach, you can rest assured that all finalizable objects have had a chance to perform any necessary cleanup
before your program continues. Under the hood, GC.WaitForPendingFinalizers() will suspend the calling thread during the
collection process. This is a good thing, as it ensures your code does not invoke methods on an objects currently being destroyed!

When you override Finalize() for your custom classes, you establish a specific location to perform any necessary cleanup logic
for your type. Given that this member is defined as protected, it is not possible to directly call an object's Finalize()
method from a class instance via the dot operator. Rather, the garbage collector will call an object's Finalize() method
(if supported) before removing the object from memory.

It is illegal to override Finalize() on structure types. This makes perfect sense given that structures are value types, which are
never allocated on the heap to begin with and, therefore, are not garbage collected! However, if you create a structure that
contains unmanaged resources that need to be cleaned up, you can implement the IDisposable interface.

The only time you would need to design a class that can cleanup after itself is when you are using unmanaged resources (such as
raw OS file handles, raw unmanaged database connections, chunks of unmanaged memory, or other unmanaged resources).

The only compelling reason to override Finalize() is if your C# class is using unmanaged resources via PInvoke or complex COM 
interoperability tasks (typically via various members defined by the System.Runtime.InteropServices.Marshall type).
The reason is that under these scenarios you are manipulating memory that the CLR cannnot manage.

C# finalizers look similar to constructors in that they are named identically to the class they are defined within.
In addition, finalizers are prefixed with a tilde symbol (~). Unlike a constructor, however, a finalizer never takes an access
modifier (they are implicitly protected), never takes parameters, and can't be overloaded (only one finalizer per class).

When you allocate an object onto the managed heap, the runtime automatically determines whether your object supports a custom
Finalize() method. If so, the object is marked as finalizable, and a pointer to this object is stored on an internal queue named
the finalization queue. The finalization queue is a table maintained by the garbage collector that points to every object that must
be finalized before it is removed from the heap.
When the garbage collector determines it is time to free an object from memory, it examines each entry on the finalization queue
and copies the object off the heap to yet another managed structure termed the finalization reachable table (often abbreaviated as
freachable and pronounced "eff-reachable"). At this point, a separate thread is spawned to invoke the Finalize() method for each
object on the freachable table at the next garbage collection. Given this, it will take, at the least, two garbage collections to 
truly finalize the object.
The bottom line is that while finalization of an object does ensure an object can clean up unmanaged resources, 
it is still nondeterministic in nature and, because of the extra behind-the-curtains processing, considerably slower.

When you do implement the IDisposable interface, the assumption is that when the object user is finished using the object, 
the object user manually calls Dispose() before allowing the object reference to drop out of scope. In this way, an object can
perform any necessary cleanup of unmanaged resources without incurring the hit of being placed on the finalization queue and 
without waiting for the garbage collector to trigger the class’s finalization logic. 
Structures and class types can both implement IDisposable (unlike overriding Finalize(), which is reserved for class types),
as the object user (not the garbage collector) invokes the Dispose() method.

It is a good idea to call Dispose() on any object you directly create if the object supports IDisposable. The assumption you should 
make is that if the class designer choose to support the Dispose() method, the type has some cleanup to perform. 
If you forget, memory will eventually be cleaned up (so don’t panic), but it could take longer than necessary.

The C# using keyword now has a double meaning: importing namespaces and invoking a Dispose() method. Nevertheless, when you
are working with .NET types that support the IDisposable interface, this syntactical construct will ensure that the object “being used” 
will automatically have its Dispose() method called once the using block has exited. Also, be aware that it is possible 
to declare multiple objects of the same type within a using scope. As you would expect, the compiler will inject code 
to call Dispose() on each declared object.

After an object has been “disposed”, it’s still possible for the client to invoke members on it, as it is still in memory. 
Therefore, a robust resource wrapper class would also need to update each member of the class with additional coding logic that says, 
in effect, “If I am disposed, do nothing and return from the member.”

The base class libraries provide a useful generic class named Lazy<>, defined in the System namespace of mscorlib.dll. 
This class allows you to define data that will not be created unless your code base actually uses it. As this is a generic class, you
must specify the type of item to be created on first use, which can be any type with the .NET base class libraries or 
a custom type you have authored yourself.
Lazy object instantiation is useful not only to decrease allocation of unnecessary objects. You can also use this technique if 
a given member has expensive creation code, such as invoking a remote method, communication with a relational database, or what not.

				PART V Programming with .NET Assemblies

		Chapter 14 Building and Configuring Class Libraries

Technically speaking, you are not required to use the C# using keyword when reffering to types defined in external namespaces. You could
use the fully qualified name of the type, which is the type's name prefixed with the defining namespace.

The C# using keyword also lets you create an alias for a type's fully qualified name. When you do so, you define a token that is
substituted for the type's full name at compile time. Defining aliases provides a second way to resolve name clashes.
The alternative using syntax also lets you create an alias for a lengthy namespace.
Be aware that overuse of C# aliases can result in a confusing code base. If other programmers on your team are unaware of your custom
aliases, they could assume the alliase refer to types in the .NET base class libraries and become quite confused when they can't
find these tokens in the .NET Framework SDK documentation!

When organizing your types, you are free to define namespaces within other namespaces. The .NET base class libraries do so in
numerous places to provide deeper levels of type organization.

.NET applications are constructed by piecing together any number of assemblies. Simply put, an assembly is a versioned, 
self-describing binary file hosted by the CLR. Now, despite that .NET assemblies have the same file extensions (*.exe or *.dll)
as previous Windows binaries, that have little in common with those files under the hood.

As you might now, a code library (also termed a class library) is a *.dll that contains types intended to be used by external
application.

Recall that a type's fully qualified name is composed by prefixing the type's namespace (e.g., System) to its name (e.g., Console).
Assemblies are regarded as self-describing, in part because they record every external assembly they must have access to in order
to function correctly.

Assemblies can be deployed as "private" or "shared". Private assemblies reside in the same directory (or possibly a subdirectory)
as the client application that uses them. Shared assemblies, on the other hand, are libraries intended to be consumed by numerous
applications on a single machine and are deployed to a specific directory termed the global assembly cache, or GAC.

A .NET assembly (*.dll or *.exe) consists of the following elements:
- a Windows file header
- a CLR file header
- CIL code
- type metadata
- an assembly manifest
- optional embedded resources

The Windows file header establishes the fact that the assembly can be loaded and manipulated by the Windows family of operating
system. This header data also identifies the kind of application (console-based, GUI-based, ot *.dll code library) to be hosted
by Windows.

The CLR file header is a block of data that all .NET assemblies must support (and do support, courtesy of the C# compiler) to be
hosted by the CLR. In a nutshell, this header defines numerous flags that enable the runtime to understand the layout of the 
managed file.

An assembly contains CIL code, which, as you recall, is a platform- and CPU-agnostic intermediate language. At runtime, 
the internal CIL is compiled on the fly using a just-in-time (JIT) compiler, according to platform- and CPU-specific
instructions. Given this design, .NET assemblies can indeed execute on a variety of architectures, devices, and operating systems.
An assembly also contains metadata that completely describes the format of the contained types, as well as the format of 
external types referenced by this assembly. The .NET runtime uses this metadata to resolve the location of types (and their members)
within the binary, lay out types in memory, and facilitate remote method invocations.
An assembly must also contain an associated manifest (also referred to as assembly metadata). The manifest documents each module
within the assembly, establishes the version of the assembly, and also documents any external assemblies referenced by the current
assembly. 

When you reference private assemblies in new applications, the IDE responds by placing a copy of the library in the client
application's output directory.

The .NET runtime resolves the location of a private assembly using a technique called probing, which is much less invasive than
it sounds. Probing is the process of mapping an external assembly request to the location of the requested binary file.
Strictly speaking, a request to load an assembly may be either implicit or explicit. An implicit load request occurs when
the CLR consults the manifest to resolve the location of an assembly defined using the assembly extern tokens.
An explicit load request occurs programmatically using the Load() or LoadFrom() method of the System.Reflection.Assembly
class type, typically for the purposes of late binding and dynamic invocation of type members.

Technically speaking, if a copy of the requested assembly cannot be found within the client's application directory,
the CLR will also attempt to locate a client subdirectory with the same name as the assembly's friendly name. If the requested
assemlby resides within this subdirectory, the CLR will load the assembly into memory.

Remember, that *.config file must be prefixed with the same name as the related client application.

A shared assembly is a collection of types intended for reuse among projects. The most obvious difference
between shared and private assemblies is that a single copy of a shared assembly can be used by several
applications on the same machine.
Deciding whether a code library should be deployed as a private or shared library is yet another design issue
to contend with, and this will be based on many project-specific details. As a rule of thumb, when you are
building libraries that need to be used with a wide variety of applications, shared assemblies can be quite
helpful in that they can be updated to new version easily.

A hash code is a numerical value that is statistically unique for a fixed input. Thus, if you modify any
aspect of a .NET assembly (even a single character in a string literal), the compiler yields a different
hash code.

		Chapter 15 Type Reflection, Late Binding, and Attribute-Based Programming

The ability to fully describe types (classes, interfaces, structures, enumerations, and delegates) using
metadata is a key element of the .NET platform. If you open any of the *.dll or *.exe assemblies using
ildasm.exe and press Ctrl+M, you would find the relevant type metadata.

Always be aware that all strings are clearly documented in the assembly metadata. This could have huge
security consequences if you were to use string literals to capture passwords, credit card numbers, or
other sensitive information.

In .NET universe, reflection is the process of runtime type discovery. Using reflection services, you are
able to programmatically obtain the same metadata information displayed by ildasm.exe using a friendly
object model. For example, through reflection, you can obtain a list of all types contained within a given
*.dll or *.exe assembly, including the methods, fields, properties, and events defined by a given type.
You can also dynamically discover the set of interfaces supported by a given type, the parameters of a 
method, and other related details (base classes, namespace information, manifest data, and so forth).

A Sampling of Members of the System.Reflection Namespace
----------------------------------------------------------------------------------------------------------------
Type							Meaning in Life						|
----------------------------------------------------------------------------------------------------------------
Assembly					This abstract class contains a number of members that allow	|
						you to load, investigate, and manipulate an assembly.		|
AssemblyName					This class allows you to discover numerous details behind	|
						an assembly's identity (version information, culture		|
						information, and so forth).					|
EventInfo					This abstract class holds information for a given event.	|
FieldInfo					This abstract class holds information for a given field.	|
MemberInfo					This is the abstract base class that defines common behavior	|
						for the EventInfo, FieldInfo, MethodInfo, and PropertyInfo.	|
MethodInfo					This abstract class contains information for a given method.	|
Module						This abstract claas allows you to access a given module		|
						within a multiple assembly.					|
ParameterInfo					This class holds information for a given parameter.		|
PropertyInfo					This abstract class holds information for a given property.	|
----------------------------------------------------------------------------------------------------------------

The System.Type class defines a number of members that can be used to examine a type's metadata, a great number
of which return types from the System.Reflection namespace.

Select Members of System.Type
----------------------------------------------------------------------------------------------------------------
Member						Meaning in Life							|
----------------------------------------------------------------------------------------------------------------
IsAbstract				These properties (among others) allow you to discover a number		|			
IsArray					of basic traits about the Type you are referring to (e.g., if it is an	|				
IsClass					abstract entity, an array, a nested class, and so forth).		|
IsCOMObject													|
IsEnum														|
IsGenericTypeDefinition												|
IsGenericParameter												|
IsInterface													|
IsPrimitive													|
IsNestedPrivate													|
IsNestedPublic													|
IsSealed													|
IsValueType													|
GetConstructors()			These methods (among others) allow you to obtain an array		|
GetEvents()				representing the items (interface, method, property, etc.) you are	|
GetFields()				interested in. Each method returns a related array (e.g.,		|
GetInterfaces()				GetFields() returns a FieldInfo array, GetMethods()			|
GetMembers()				returns a MethodInfo array, etc.). Be aware that each of these		|
GetMethods()				methods has a singular form (e.g., GetMethod(),				|
GetNestedTypes()			GetProperty(), etc.) that allows you to retrieve a specific item	|
GetProperties()				by name, rather than an array of all related items.			|
FindMembers() 				This method returns a MemberInfo array based on search criteria.	|
GetType() 				This static method returns a Type instance given a string name.		|
InvokeMember() 				This method allows “late binding” for a given item.			|
----------------------------------------------------------------------------------------------------------------

You can not directly create a Type object using the new keyword, as Type is an abstract class.
You can obtain an information about the type using the C# typeof operator, like so:

Type t = typeof(object);

Unlike System.Object.GetType(), the typeof operator is helpful in that you do not need to first create an object
instance to extract type information. However, your code base must still have compile-time knowledge of the type
you are interested in examining, as typeof expects the strongly typed name of the type.

To obtain type information in a more flexible manner, you may call the static GetType() member of the System.Type
class and specify the fully qualified string name of the type you are interested in examining. 
The Type.GetType() method has been overloaded to allow you to specify two Boolean parameters, one of which controls
whether an exception should be thrown if the type cannot be found, and the other of which establishes the case 
sensitivity of the string.

Type t = Type.GetType("object", false, true);

Formally speaking, the act of loading external assemblies on demand is known as a dynamic load.
System.Reflection defines a class named Assembly. Using this class, you are able dynamically load an assembly, as well
as discover properties about the assembly itself. Using the assembly type, you are able to dynamically load private
or shared assemblies, as well as load an assembly located at an arbitrary location.

Late binding is a technique in which you are able to create an instance of a given type and invoke its members
at runtime without having hard-coded compile-time knowledge of its existence. The System.Activator class is the key
to the .NET late-binding process. Notice that the Activator.CreateInstance() method returns a System.Object.

The .NET platform provides a way for programmers to embed additional metadata into an assembly using attributes. 
In a nutshell, attributes are nothing more than code annotations that can be applied to a given type 
(class, interface, structure, etc.), member (property, method, etc.), assembly, or module.
 
A Tiny Sampling of Predefined Attributes
--------------------------------------------------------------------------------------------------------------------------------
Attibute						Meaning in Life								|
--------------------------------------------------------------------------------------------------------------------------------
[CLSCompliant] 					Enforces the annotated item to conform to the rules of the Common		|
						Language Specification (CLS). Recall that CLS-compliant types are		|
						guaranteed to be used seamlessly across all .NET programming languages.		|
[DllImport]					Allows .NET code to make calls to any unmanaged C- or C++-based code		|
						library, including the API of the underlying operating system. 			|
						Do note that [DllImport] is not used when communicating with COM-based		|
						software.									|
[Obsolete]					Marks a deprecated type or member. If other programmers attempt to use		|
						such an item, they will receive a compiler warning describing 			|
						the error of their ways.							|
[Serializable] 					Marks a class or structure as being “serializable,” meaning it is able to	|
						persist its current state into a stream.					|
[NonSerialized] 				Specifies that a given field in a class or structure should not be 		|
						persisted during the serialization process.					|
[ServiceContract] 				Marks a method as a contract implemented by a WCF service.			|
--------------------------------------------------------------------------------------------------------------------------------

To apply multiple attributes to a single item, simply use a comma-delimited list or you can also apply multiple attributes
on a single item by stacking each attributes.
As a naming convention, all .NET attributes (including custom attributes you may create yourself) are suffixed with the 
Attribute token. However, to simplify the process of applying attributes, the C# language does not require you to type in
the Attribute suffix.
When you supply constructor parameters to an attribute, the attribute is not allocated into memory until the parameters are
reflected upon by another type or an external tool. The string data defined at the attribute level is simply stored within
the assembly as a blurb of metadata.

You should understand the following key point regarding .NET attributes:
- attributes are classes that derive from System.Attribute
- attributes result in embedded metadata
- attributes are basically useless until another agent reflects upon them
- attributes are applied in C# using square brackets

For security reasons, it is considered a .NET best practice to design all custom attributes as sealed.

By default, custom attributes can be applied to just about any aspect of your code (methods, classes, properties, and so on).
When you may want to build a custom attribute that can be applied only to select code elements, you will need to apply
the [AttributeUsage] attribute on the definition of your custom attribute. The [AttributeUsage]	attribute allows you 
to supply any combination of values (via an OR operation) from the AttributeTarget enumeration.

Select Assembly-Level Attributes
----------------------------------------------------------------------------------------------------------------------------------------
Attribute					Meaning in Life										|
----------------------------------------------------------------------------------------------------------------------------------------
[AssemblyCompany]				Holds basic company information.							|
[AssemblyCopyright]				Holds any copyright information for the product or assembly				|
[AssemblyCulture]				Provides information on what cultures or languages the assembly supports		|
[AssemblyDescription]				Holds a friendly description of the product or modules that make up the assembly	|
[AssemblyKeyFile]				Specifies the name of the file containing the key pair used to sign the assembly	|
						(i.e., establish a strong name)								|
[AssemblyProduct]				Provides product information								|
[AssemblyTradeMark]				Provides trademark information								|
[AssemblyVersion]				Specifies the assembly's version information, in the format 				|
						<major.minor.build.revision>								|
----------------------------------------------------------------------------------------------------------------------------------------

If you want to make use of early binding, you'll require the client application to have a compile-time definition of the attribute.

When to make use of reflection, dynamic loading, late binding, and custom attributes?
1) An extendable application must provide some input mechanism to allow the user to specify the module to plug in 
(such as a dialog box or command-line flag). This requires dynamic loading.
2) An extendable application must be able to determine whether the module supports the correct functionality (such as a
set of required interfaces) to be plugged into the environment. This requires reflection.
3) An extendable application must obtain a reference to the required infrastructure (such as a set of interface types)
and invoke the members to trigger the underlying functionality. This may require late binding.

		Chapter 16 Dynamic Types and the Dynamic Language Runtime

Keyword dynamic allows you to incorporate scripting-like behaviors into the strongly typed world of type safety,
semicolons, and curly brackets. Using this loose typing, you can greatly simplify some complex coding tasks and also
gain the ability to interoperate with a number of dynamic languages, which are .NET savvy.

From a high level, you can consider the dynamic keyword a specialized form of System.Object, in that any value can be
assigned to a dynamic data type. Dynamic data is not statically typed. As far as the C# compiler is concerned, 
a data point declared with the dynamic keyword can be assigned any initial value at all and can be reassigned to
any new (and possibly unrelated) value during its lifetime.
Another obvious distinction between calling members on dynamic data and strongly typed data is that when you apply 
the dot operator to a piece of dynamic data, you will not see the expected Visual Studio IntelliSense. 
The IDE will allow you to enter any member name you could dream up.

The dynamic keyword can be used as a return value, a parameter, or a member of a class/structure.
A dynamic data item cannot make use of lambda expressions or C# anonymous methods when calling a method.
Also it has a limited use within LINQ to Objects and other LINQ technologies.

A dynamic runtime allows a dynamic language the ability to discover types completely at runtime with no 
compile-time checks.

DLR - dynamic language runtime
RCW - runtime callable wrapper

		Chapter 17 Processes, AppDomains, and Object Contexts

Application domains (or simply AppDomains) are logical subdivisions within a given process that host a set of related
.NET assemblies.
While it is true that many of your day-to-day programming tasks might not involve directly working with processes,
AppDomains, or objects contexts, understanding these topics is important when working with numerous .NET APIs,
including Windows Communications Foundation (WCF), multithreading and parallel processing, and object serialization.

The concept of a "process" existed within Windows-based operating systems well before the release of the .NET platform.
In simple terms, a process is a running program. However, formally speaking, a process is an operating system-level
concept used to describe a set of resources (such as external code libraries and the primary thread) and the necessary
memory allocations used by a running application. For each *.exe loaded into memory, the OS creates a separate and
isolated process for the use during its lifetime.
Using this approach to application isolation, the result is a much more robust and stable runtime environment,
given that the failure of the process does not affect the functioning of another. Furthermore, data in one process
cannot be directly accessed by another process, unless you make use of a distributed computing programming API such
as Windows Communication Foundation. Given these points, you can regard the process as a fixed, safe boundary for a
running application.
Now, every Windows process is assigned a unique process identifier (PID) and may be independently loaded and 
unloaded by the OS as necessary (as well as programmatically).

A thread is a path of execution within a process. Formally speaking, the first thread created by a process's
entry point is termed the primary thread. Any .NET executable program (Console Application, Windows service,
WPF application, etc.) marks its entry point with the Main() method. When this method is invoked, 
the primary thread is created automatically.
Processes that contain a single primary thread of execution are intrinsically thread safe, given the fact that
there is only one thread that can access the data in the application at a given time. However, a single-threaded
process (especially one that is GUI-based) will often appear a bit unresponsive to the user if this single thread
is performing a complex operation (such as printing out a lengthy text file, performing a mathematically 
intensive calculation, or attempting to connect to a remote server located thousands of miles away).
Given this potential drawback of single-threaded applications, the Winfows API (as well as .NET platform) makes
it possible for the primary thread to spawn additional secondary threads (also termed worker thread) using a 
handful of Windows API functions such as CreateThread(). Each thread (primary or secondary) becomes a unique path
of execution in the process and has concurrent access to all shared points of data within the process.
Multithreaded processes provide the illusion that numerous activities are happening at more or less the same time.
However, using too many threads in a single process can actually degrade performance, as the CPU must switch
between the active threads in the process (which takes time).
A single CPU will execute one thread for a unit of time (called a time slice) based in part on the thread's 
priority level. When a thread's time slice is up, the existing thread is suspended to allow another thread
to perform its business. For a thread to remember what was happening before it was kicked out of the way, each 
thread is given the ability to write to Thread Local Storage (TLS) and is provided with a separate call stack.

Select Members of the System.Diagnostics Namespace
---------------------------------------------------------------------------------------------------------------------
Process-Centric Types of the				Meaning in Life						     |
System.Diagnostics Namespace											     |
---------------------------------------------------------------------------------------------------------------------
Process							The Process class provides access to local and remote 	     |
							processes and also allows you yo programatically start	     |
							and stop processes.					     |
ProcessModule						This type represents a module (*.dll or *.exe) that is	     |
							loaded into a particular process. Understand that the        |
							ProcessModule type can represent any module - COM-based,     |
							.NET-based, or traditional C-based binaries.		     |
ProcessModuleCollection					This provides a strongly typed collection of ProcessModule   |
							objects.						     |
ProcessStartInfo					This specifies a set of values used when starting a process  |
							via the Process.Start() method.				     |
ProcessThread						This type represents a thread within a given process.	     |
							Be aware that ProcessThread is a type used to diagnose a     |
							process's thread set and is not used to spawn new threads    |
							of execution within a process.				     |
ProcessThreadCollection					This provides a strongly typed collection of ProcessThread   |
							objects.						     |
---------------------------------------------------------------------------------------------------------------------

Select Properties of the Process Type
------------------------------------------------------------------------------------------------------------------------
Property					Meaning in Life								|
------------------------------------------------------------------------------------------------------------------------
ExitTime					This property gets the timestamp associated with the process		|
						that has terminated (represented with a DateTime type).			|
Handle						This property returns the handle (represented by an IntPtr)		|
						associated to the process by the OS. This can be helpful when		|
						building .NET applications that need to communicate with		|
						unmanaged code.								|
Id						This property gets the PID for the associated process.			|
MachineName					This property gets the name of the computer the associated process	|
						is running on.								|
MainWindowTitle					MainWindowTitle gets the caption of the main window of the process	|
						(if the process does not have a main window, you receive an empty	|
						string).								|
Modules						This property provides access to the strongly typed			|
						ProcessModuleCollection type, which represents the set of modules	|
						(*.dll or *.exe) loaded within the current process.			|
ProcessName					This property gets the name of the process (which, as you would		|
						assume, is the name of the application itself).				|
Responding					This property gets a value indicating whether the user interface	|
						of the process is responding to user input (or is currently "hung")	|
StartTime					This property gets the time that the associated process was started	|
						(via a DateTime type).							|
Threads						This property gets the set of threads that are running in the		|
						associated process (represented via a collection of ProcessThread	|
						objects).								|
------------------------------------------------------------------------------------------------------------------------

Select Methods of the Process Type
--------------------------------------------------------------------------------------------------------------------
Method					Meaning in Life								    |
--------------------------------------------------------------------------------------------------------------------
CloseMainWindow()			This method closes a process that has a user interdface by sending a close  |
					message to its main window.						    |
GetCurrentProcess()			This static method returns a new Process object that represents the	    |
					currently active process.						    |
GetProcesses()				This static method returns an array of new Process objects running on a	    |
					given machine.								    |
Kill()					This method immediately stops the associated process.			    |
Start()					This method starts a process.						    |
--------------------------------------------------------------------------------------------------------------------
	
Select Members of the ProcessThread Type
------------------------------------------------------------------------------------------------------------------------
Member					Meaning in Life									|
------------------------------------------------------------------------------------------------------------------------
CurrentPriority				Gets the current priority of the thread						|
Id					Get the unique identifier of the thread						|
IdealProcessor				Sets the preferred processor for this thread to run on				|
PriorityLevel				Get or sets the priority level of the thread					|
ProcessorAffinity			Sets the processor on which the associated thread can run			|
StartAddress				Gets the memory address of the function that the operating system called	|
					that started this thread							|
StartTime				Gets the time that the operating system started the thread			|
ThreadState				Gets the current state of this thread						|
TotalProcessorTime			Gets the local amount of time that this thread has spent using the processor	|
WaitReason				Gets the reason that the thread is waiting					|
------------------------------------------------------------------------------------------------------------------------

A .NET executable is hosted by a logical partition within a process termed as application domain.

Select Methods of AppDomain
------------------------------------------------------------------------------------------------------------------------
Method					Meaning in Life									|
------------------------------------------------------------------------------------------------------------------------
CreateDomain()				This static method allows you to create a new AppDomain in the current		|
					process										|
CreateInstance()			This creates an instance of a type in an external assembly, after loading	|																																																																																					
					said assembly into the calling application domain.				|
ExecuteAssembly()			This method executes an *.exe assembly within an applicaton domain, given its	|
					file name.									|
GetAssemblies()				This method gets the set of .NET assemblies that have beem loaded into this	|
					application domain (COM-based or C-based binaries are ignored).			|
GetCurrentThreadId()			This static method returns the ID of the active thread in the current		|
					application domain.								|
Load()					This method is used to dynamically load an assembly into the current		|
					application domain.								|
Unload()				This is another static method that allows you to unload a specified AppDomain	|
					within a given process.								|
------------------------------------------------------------------------------------------------------------------------

Select Properties of AppDomain
------------------------------------------------------------------------------------------------------------------------
Property				Meaning in Life									|
------------------------------------------------------------------------------------------------------------------------
BaseDirectory				This gets the directory path that the assembly resolver uses to probe for	|
					assemblies.									|
CurrentDomain				This static property gets the application domain for the currently		|
					executing thread								|
FriendlyName				This gets the friendly name of the current application domain.			|
MonitoringIsEnabled			This gets or sets a value that indicates whether CPU and memory monitoring	|
					of application domains is enabled for the current process. Once monitoring	|
					is enabled for a process, it cannot be disabled.				|																																																																																																																																																																																																																																															
SetupInformation			This gets the configuration details for a given application domain, 		|
					represented by an AppDomainsSetup object.					|
------------------------------------------------------------------------------------------------------------------------

Select Events of the AppDomain Type
------------------------------------------------------------------------------------------------------------------------
Event					Meaning in Life									|
------------------------------------------------------------------------------------------------------------------------
AssemblyLoad				This occurs when an assembly is loaded into memory.				|
AssemblyResolve				This event will fire when the assembly resolver cannot find the location	|
					of a required assembly.								|
DomainUnload				This occurs when an AppDomain is about to be unloaded from the hosting		|
					process.									|
FirstChanceException			This event allows you to be notified that an exception has been thrown		|
					from the application domain, before the CLR will begin looking for a fitting	|
					catch statement.								|
ProcessExit				This occurs on the default application domain when the default application	|
					domain's parent process exits.							|
UnhandledException 			This occurs when an exception is not caught by an exception handler.		|
------------------------------------------------------------------------------------------------------------------------

		Chapter 18 Understanding CIL and the Role of Dynamic Assemblies

CIL directives are used to inform the CIL compiler how to define the namespace(s), type(s), and member(s) that will
populate an assembly. Many CIL directives can be further specified with various CIL attributes to qualify how a directive
should be processed. Once a .NET assembly, namespace, and type set have been defined in terms of CIL using various
directives and related attributes, the final remaining task is to provide the type's implementation logic - this is a 
job for operations code, or simply opcodes.

				PART VI Introducing the .NET Base Class libraries

		Chapter 19 Multithreaded, Parallel, and Async Programming

There are three recent techniques .NET developers can use to build multithreaded software, specifically the 
Task Parallel Library (TPL), Parallel LINQ (PLINQ), and the new intrinsic asynchronous keywords of C# (async and await).

Under the .NET platform, there is not a direct one-to-one correspondence between application domains and threads. In fact,
a given AppDomain can have numerous threads executing within it at any given time. Furthermore, a particular thread is 
not confined to a single application domain during its lifetime. Threads are free to cross application domain boundaries
as the Windows OS thread scheduler and the .NET CLR see fit.
Although active threads can be moved between AppDomain boundaries, a given thread can execute within only a single
application domain at any point in time (in other words, it is impossible for a single thread to be doing work in more
than one AppDomain at once).

One of the many "joys" (read: painful aspects) of multithreaded programming is that you have little control over how the 
underlying operating system or the CLR uses its threads. For example, if you craft a block of code that creates a new thread
of execution, you cannot guarantee that the thread executes immediately. Rather, such code only instructs the OS/CLR to execute
the thread as soon as possible (which is typically when the thread scheduler gets around it).
Furthermore, given that the threads can be moved between application and contextual boundaries as required by the CLR, you must
be mindful of which aspects of your application are thread-volatile (e.g., subject to multithreaded access) and which operations
are atomic (thread-volatile operations are the dangerous ones!);

To protect an application's resources from possible corruption, .NET developers must use any number of threading primitives
(such as locks, monitors, and the [Synchronization] attribute or language keyword support) to control access among the
executive threads.

Using types defined within the System.Threading namespace, the Task Parallel Library (TPL), and the C# async and await keywords,
you are able to work with multiple threads with minimal fuss and bother.

To allow the calling thread to discover whether the asynchronously invoked method has completed its work, the IAsyncResult
interface provides the IsCompleted property. Using this member, the calling thread is able to determine whether the
asynchronous call has indeed completed before calling EndInvoke().
If the method has not completed, IsCompleted returns false, and the calling thread is free to carry on its work.
If IsCompleted returns true, the calling thread is able to obtain the result in the "least blocking manner" possible.

Core Types of the System.Threading Namespace
--------------------------------------------------------------------------------------------------------------------------------
Type						Meaning in Life									|
--------------------------------------------------------------------------------------------------------------------------------
Interlocked					This type provides atomic operations for variables that are shared by 		|
						multiple threads.								|
Monitor						This type provides the synchronization of threading objects using locks and	|
						wait/signals. The C# lock keyword uses a Monitor object under the hood.		|
Mutex						This synchronization primitive can be used for synchronization between		|
						application domain boundaries.							|
ParameterizedThreadStart			This delegate allows a thread to call methods that take any number of		|
						arguments.									|
Semaphore					This type allows you to limit the number of threads that can access		|
						a resource, or a particular type of resource, concurrently.			|
Thread						This type represents a thread that executes within the CLR. Using this type,	|
						you are able to spawn additional threads in the originating AppDomain.		|
ThreadPool					This type allows you to interact with the CLR-maintained thread pool		|
						within a given process.								|
ThreadPriority					This enum represents a thread's priority level (Highest, Normal, etc.).		|
ThreadStart					This delegate is used to specify the method to call for a given thread.		|
						Unlike the ParameterizedThreadStart delegate, targets of ThreadStart		|
						must always have the same prototype.						|
ThreadState					This enum specifies the valid states a thread may take (Running,		|
						Aborted, etc.).									|
Timer						This type provides a mechanism for executing a method at specified		|
						intervals.									|
TimerCallback					This delegate type is used in conjunction with Timer types.			|
--------------------------------------------------------------------------------------------------------------------------------

The most primitive of all types in the System.Threading namespace is Thread. This class represents an object-oriented wrapper
around a given path of execution within a particular AppDomain. This type also defines a number of methods (both static and
istance level) that allow you to create new threads within the current AppDomain, as well as to suspend, stop, and destroy
a particular thread.

Key Static Members of the Thread Type
--------------------------------------------------------------------------------------------------------------------------------
Static Member			Meaning in Life											|
--------------------------------------------------------------------------------------------------------------------------------
CurrentContext			This read-only property returns the context in which the thread is currently running.		|
CurrentThread			This read-only property returns a reference to the currently running thread.			|
GetDomain()			These methods return a reference to the current AppDomain or the ID of the domain in which	|
GetDomainID()			the current thread is running.									|
Sleep()				This method suspends the current thread for a specified time.					|
--------------------------------------------------------------------------------------------------------------------------------

Select Instance-Level Members of the Thread Type
--------------------------------------------------------------------------------------------------------------------------------
Instance-Level Member				Meaning in Life									|
--------------------------------------------------------------------------------------------------------------------------------
IsAlive						Returns a Boolean that indicates whether this thread has been started 		|
						(and has not yet terminated or aborted).					|
IsBackground					Gets or sets a value indicating whether this thread is a "background thread".	|
Name						Allows you to establish a friendly text name of the thread.			|
Priority					Gets or sets the priority of a thread, which may be assigned a value from	|
						the ThreadPriority enumeration.							|
ThreadState					Gets the state of this thread, which may be assigned a value from the 		|
						ThreadState enumeration.							|
Abort()						Instructs the CLR to terminate the thread as soon as possible.			|
Interrupt()					Interrupts (e.g., wakes) the current thread from a suitable wait period.	|
Join()						Blocks the calling thread until the specified thread (the one on which Join() 	|
						is called) exists.								|
Resume()					Resumes a thread that has been previously suspended.				|
Start()						Instructs the CLR to execute the thread ASAP.					|
Suspend()					Suspends the thread. If the thread is already suspended, a call to Suspend()	|
						has no effect.									|
--------------------------------------------------------------------------------------------------------------------------------		

Aborting or suspending an active thread is generally considered a bad idea. When you do so, there is a chance (however small)
that a thread could "leak" its workload when disturbed or terminated.

One simple, and thread-safe, way to force a thread to wait until another is completed is to use the AutoResetEvent class.
In the thread that need to wait (such as a Main() method), create an instance of this class and pass in false to the 
constructor to signify you have not yet been notified. Then, at the point at which you are willing to wait, 
call the WaitOne() method.

Let's formalize the disctinction between foreground threads and background threads:
- Foreground threads have the ability to prevent the current application from terminating. The CLR will not shut down an application
(which is to say, unload the hosting AppDomain) until all foreground thread have ended.
- Background threads (sometimes called daemon threads) are viewed by the CLR as expendable paths of execution that can be ignored
at any point in time (even if they are currently laboring over some unit of work). Thus, if all foreground threads have
terminated, any and all background threads are automatically killed when the application domain unloads.
It is important to note that foreground and background threads are not synonymous with primary and worker threads. By default,
every thread you create via the Thread.Start() method is automatically a foreground thread. Again, this means that the AppDomain
will not unload until all threads of execution have completed their units of work. In most cases, this is exactly the behavior
you require.

When you build multithreaded applications, your program needs to ensure that any piece of shared data is protected against the
possibility of numerous threads changing its value. Given that all threads in an AppDomain have concurrent access to the 
shared data of the application, imagine that might happen if multiple threads were accessing the same point of data.

The first technique you can use to synchronize access to shared resources is the C# lock keyword. This keyword allows you
to define a scope of statements that must be synchronized between threads. By doing so, incoming threads cannot interrupt
the current thread, thus preventing it from finishing its work. The lock keyword requires you to specify a token
(an object reference) that must be acquired by a thread to enter within the lock scope. When you are attempting to lock down
a private instance-level method, you can simply pass in reference to the current type. However, if you are locking down
a region of code within a public method, it is safer (and a best practice) to declare a private object member variable 
to serve as the lock token.

Once a thread enters into a lock scope, the lock token is inaccessible by other threads until the lock is released after
the lock scope has exited. Thus, if thread A has obtained the lock token, other threads are unable to enter any scope that
uses the same lock token until thread A relinquishes the lock token.

If you are attempting to lock down the code in a static method, simply declare private static object member variable
to serve as the lock token.

The C# lock statement is really just a shorthand notation for working with the System.Threading.Monitor class.

First, notice that the Monitor.Enter() method is the ultimate recipient of the thread token you specified as the argument
to the lock keyword. Next, all code within a lock scope is wrapped within a try block. The corresponding finally clause
ensures that the thread token is released (via the Monitor.Exit() method), regardless of any possible runtime exception.

Although it always is hard to believe until you look at the underlying CIL code, assingments and simple arithmetic operations
are not atomic.

Select Static Members of the System.Threading.Interlocked Type
------------------------------------------------------------------------------------------------------------------------
Member						Meaning in Life								|
------------------------------------------------------------------------------------------------------------------------
CompareExchange()				Safely tests two values for equality and, if equal, exchanges one 	|
						of the values with a third.						|
Decrement()					Safely decremenents a value by 1.					|
Exchange()					Safely swaps two values.						|
Increment()					Safely increments a value by 1.						|
------------------------------------------------------------------------------------------------------------------------
	
The class-level attribute [Synchronization] effectively locks down all instance member code of the object for thread safety.
When the CLR allocates objects attributed with [Synchronization], it will place the object within a synchronized context.

When you invoke a method asynchronously using delegate types (via the BeginInvoke() method), the CLR does not literally
create a new thread. For purposes of efficiency, a delegate's BeginInvoke() method leverages a pool of worker delegates
that is maintained by the runtime. To allow you to interact with this pool of waiting threads, the System.Threading
namespace provides the ThreadPool class type.
If you want to queue a method call for processing by a worker thread in the pool, you can use the
ThreadPool.QueueUserWorkItem() method.

You might be wondering if it would be advantegous to use the CLR-maintained thread pool rather than explicitly creating
Thread objects. Consider these benefits of leveraging the thread pool:
- the thread pool manages threads efficiently by minimize the number of threads that must be created, started, and
  stopped
- by using the thread pool, you can focus on your business problem rather than the application's threading 
  infrastructure

However, using manual thread management is preferred in some cases:
- if you require foreground threads or must set the thread priority. Pooled threads are always background threads
  with default priority (ThreadPriority.Normal)
- if you require a thread with a fixed identity in order to abort it, suspend it, or discover it by name

Beginning with the release of .NET 4.0, Microsoft introduced a new approach to multithreaded application development
using a parallel programming library termed Task Parallel Library (TPL). Collectively speaking, the types of
System.Threading.Tasks are referred to as the Task Parallel Library. Using the System.Threading.Tasks, you can
build fine-grained, scalable parallel code without having to work directly with threads or the thread pool.
Be aware that the C# async and await keywords use various members of the System.Threading.Tasks namespace.

The TPL will automatically distribute your application's workload across available CPUs dynamically, using
the CLR thread pool. The TPL handles the partitioning of the work, thread scheduling, state management, and other
low-level details. The end result is that you can maximize the performance of your .NET applications, while being
shielded from many of complexities of directly working with threads.

A key class of the TPL is System.Threading.Tasks.Parallel.
The first way to use the TPL is to perform data parallelism. Simply put, this term refers to the task of iterating
over an array or collection in a parallel manner using the Parallel.For() or Parallel.ForEach() method.

When you are building a multithreaded graphical user interface (GUI) application, secondary threads can never directly
access user interface controls. The reason is that controls (buttons, text boxes, labels, progress bars, etc.) have 
thread affinity with the thread that created them.

One approach that you can use to allow the secondary thread to access the controls in a thread-safe manner is yet 
another delegate centric technique, specifically an anonymous delegate.

The Task class allows you to easily invoke a method on a secondary thread and can be used as a simple alternative
to working with asynchronous delegates.

LINQ queries that are designed to run in parallel are termed PLINQ queries.
Like parallel code authored using the Parallel class, PLINQ has the option of ignoring your request to process
the collection in parallel if need be. The PLINQ framework has been optimized in numerous ways, which includes
determining whether a query would, in fact, perform faster in a synchronous matter.
At runtime, PLINQ analyzes the overall structure of the query, and if the query is likely to benefit from 
parallelization, it will run concurrently. However, if parallelizing a query would hurt performance, PLINQ just
runs the query sequentially. If PLINQ has a choice between a potentially expensive parallel algorithm or an
inexpensive sequential algorithm, it chooses the sequential algorithm by default.

Select Members of the ParallelEnumerable Class
------------------------------------------------------------------------------------------------------------------------
Member					Meaning in Life									|
------------------------------------------------------------------------------------------------------------------------
AsParallel()				Specifies that the rest of the query should be parallelized, if possible.	|
WithCancellation()			Specifies that PLINQ should periodically monitor the state of the provided	|
					cancellation token and cancel execution if it is requested.			|
WithDegreeOfParallelism()		Specifies the maximum number of processors that PLINQ should use 		|
					to parallelize the query.							|
ForAll()				Enables results to be processed in parallel without first merging back		|
					to the consumer thread, as would be the case when enumerating a LINQ		|
					result using the foreach keyword.						|
------------------------------------------------------------------------------------------------------------------------

The async keyword of C# is used to qualify that a method, lambda expression, or anonymous method should be called in an
asynchronous manner automatically. Simply by marking a method with the async modifier, the CLR will create a new thread 
of execution to handle the task at hand. Furthermore, when you are calling an async method, the await keyword will
automatically pause the current thread from any further activity until the task is complete, leaving the calling thread
free to continue on its merry way.

The await token is in charge of extracting out the internal return value contained in the Task object.
An "awaitable" method is simply a method that returns a Task<T>.
Given that methods that return Task objects can now be called in a nonblocking manner via the async and await tokens,
Microsoft recommends (as a best practice) that any method returning Task be marked with an Async suffix. In this way,
developers who know the naming convention receive a visual reminder that the await keyword is required, if they
intend to invoke the method within an asynchronous context.

Event handlers for GUI controls (such as your button Click handler) that use the async/await keywords do not follow
this naming convention.

It is completely permissible for a single async method to have multiple await contexts within its implementation.

Let's summarize the key points:
- methods (as well as lambda expressions or anonymous methods) can be marked with the async keyword to enable
  the method to do work in a nonblocking manner
- methods (as well as lambda expressions or anonymous methods) marked with the async keyword will run in a blocking
  manner until the await keyword is encountered
- a single async method can have multiple await contexts
- when the await expression is encountered, the calling thread is suspended until the awaited task is completed.
  In the meantime, control is returned to the caller of the method.
- the await keyword will hide the returned Task object from view, appearing to directly return the underlying
  return value. Methods with no return value simply return void.
- as a naming convention, methods that are to be called asynchronously should be marked with the Async suffix

The Main() method of an executable cannot be marked with the async keyword.

		Chapter 20 File I/O and Object Serialization

Key Members of the System.IO Namespace
----------------------------------------------------------------------------------------------------------------
Nonabstract I/O Class Type			Meaning in Life							|
----------------------------------------------------------------------------------------------------------------
BinaryReader					These classes allow you to store and retrieve primitive data	|
BinaryWriter					types (integers, Booleans, strings, and whatnot) as a binary	|
						value).								|
BufferedStream					This class provides temporary storage for a stream of bytes 	|
						that you can commit to storage at later time.			|
Directory					You use these classes to manipulate a machine's directory	|
DirectoryInfo					structure. The Directory type exposes functionality using	|
						static members, while the DirectoryInfo type exposes similar	|
						functionality from a valid object reference.			|
DriveInfo					This class provides detailed information regarding the drives	|
						that a given machine uses.					|
File						You use these classes to manipulate a machine's set of files.	|
FileInfo					The File type exposes functionality using static members,	|
						while the FileInfo type exposes similar functionality from	|
						a valid object reference.					|
FileStream					This class gives you random file access (e.g., seeking 		|
						capabilities) with data represented as a stream of bytes.	|
FileSystemWatcher				This class allows you to monitor the modification of external	|
						files in a specified directory.					|
MemoryStream					This class provides random access to streamed data stored	|
						in memory rather than in a physical file.			|
Path						This class performs operations on System.String types that	|
						contain file or directory path information in a 		|
						platform-neutral manner.					|
StreamReader					You use these classes to store (and retrieve) textual		|			
StreamWriter					information to (or from) a file. These types do not support	|
						random file access.						|
StringReader					Like the StreamReader/StreamWriter classes, these classes also	|
StringWriter					work with textual information. However, the underlying storage	|
						is a string buffer rather than a physical file.			|
----------------------------------------------------------------------------------------------------------------

System.IO provides four classes that allow you to manipulate individual files, as well as interact with a 
machine's directory structure. The first two types, Directory and File, expose creation, deletion, copying, and
moving operations using various static members. The closely related FileInfo and DirectoryInfo types expose 
similar functionality as instance-level methods (therefore, you must allocate them with the new keyword).
FileInfo and DirectoryInfo typically serve as better choices for obtaining full details of a file or directory
(e.g., time created or read/write capabilities) because their members tend to return strongly typed objects.
In contrast, the Directory and File class members tend to return simple string values rather than strongly
typed objects.

FileSystemInfo Properties
----------------------------------------------------------------------------------------------------------------
Property			Meaning in Life									|
----------------------------------------------------------------------------------------------------------------
Attributes			Gets or sets the attributes associated with the current file that are		|
				represented by the FileAttributes enumeration (e.g., is the file or		|
				directory read-only, encrypted, hidden, or compresed?).				|
CreationTime			Gets or sets the time of creation for the current file or directory.		|
Exists				Determines whether a given file or directory exists.				|
Extension			Retrieves a file's extension.							|
FullName			Gets the full path of the directory or file.					|
LastAccessTime			Gets or sets the time the current file or directory aws last accessed.		|
LastWriteTime			Gets or sets the time when the current file or directory was last written to.	|
Name				Obtains the name of the current file or directory.				|
----------------------------------------------------------------------------------------------------------------

Key Members of the DirectoryInfo Type
----------------------------------------------------------------------------------------------------------------
Member				Meaning in Life									|
----------------------------------------------------------------------------------------------------------------
Create()			Create a directory (or set of subdirectories) when given a path name		|
CreateSubdirectory()												|
Delete()			Deletes a directory and all its contents					|
GetDirectories()		Returns an array of DirectoryInfo objects that represent all subdirectories	|
				in the current directory							|
GetFiles()			Retrieves an array of FileInfo objects that represent a set of files in the	|
				given directory									|
MoveTo()			Moves a directory and its contents to a new path				|
Parent				Retrieves the parent directory of this directory				|
Root				Gets the root portion of a path							|
----------------------------------------------------------------------------------------------------------------

FileInfo Core Members
----------------------------------------------------------------------------------------------------------------
Member				Meaning in Life									|
----------------------------------------------------------------------------------------------------------------
AppendText()			Creates a StreamWriter object that appends text to a file			|
CopyTo()			Copies an existing file to a new file						|
Create()			Creates a new file and returns a FileStream object to interact with the newly	|
				created file.									|
CreateText()			Creates a StreamWriter object that writes a new text file			|
Delete()			Deletes the file to which a FileInfo instance is bound				|
Directory			Gets an instance of the parent directory					|
DirectoryName			Gets the full path to the parent directory					|
Length				Gets the size of the current file						|
MoveTo()			Moves a specified file to a new location, providing the option to specify	|
				a new file name									|
Name				Gets the name of the file							|
Open()				Opens a new file with various read/write and sharing privileges			|
OpenRead()			Creates a read-only FileStream object						|
OpenText()			Creates a StreamReader object that reads from an existing text file		|
OpenWrite()			Creates a write-only FileStream object						|
----------------------------------------------------------------------------------------------------------------

Members of the FileMode Enumeration
----------------------------------------------------------------------------------------------------------------
Member				Meaning in Life									|
----------------------------------------------------------------------------------------------------------------
CreateNew			Informs the OS to make a new file. If it already exists, an IOException is 	|
				thrown.										|
Create				Informs the OS to make a new file. If it already exists, it will be 		|
				overwritten.									|
Open				Opens an existing file. If the file does not exist, a FileNotFoundException	|
				is thrown.									|
OpenOrCreate			Opens the file if it exists; otherwise, a new file is created.			|
Truncate			Opens an existing file and truncates the file to 0 bytes in size.		|
Append				Opens a file, moves to the end of the file, and begins write operation 		|
				(you can use this flag only with a write-only stream). 				|
				If the file does not exist, a new file is created.				|
----------------------------------------------------------------------------------------------------------------

Method of the File Type
----------------------------------------------------------------------------------------------------------------
Method				Meaning in Life									|
----------------------------------------------------------------------------------------------------------------
ReadAllBytes()			Opens the specified file, returns the binary data as an array of bytes,		|
				and then closes the file							|
ReadAllLines()			Opens a specified file, returns the character data as an array of strings,	|
				and then closes the file							|
ReadAllText()			Opens a specified file, returns the characted data as a System.String, and	|
				then closes the file.								|
WriteAllBytes()			Opens the specified file, writes out the byte array, and then closes the file.	|
WriteAllLines()			Opens a specified file, writes out an array of strings, and then closes		|
				the file									|
WriteAllText()			Opens a specified file, writes the character data from a specified string, and	|
				then closes the file								|
----------------------------------------------------------------------------------------------------------------

In the world of I/O manipulation, a stream represents a chunk of data flowing between a source and destination.
Streams provide a common way to interact with a sequence of bytes, regardless of what kind of device (e.g., file,
network, connection, or printer) stores or displays the bytes in question.

The concept of a stream is not limited to file I/O. To be sure, the .NET libraries provide stream access to
networks, memory locations, and other srtream-centric abstractions.

Abstract Stream Members
----------------------------------------------------------------------------------------------------------------
Member				Meaning in Life									|
----------------------------------------------------------------------------------------------------------------
CanRead				Determined whether the current stream supports reading, seeking, and/or		|
CanWrite			writing										|
CanSeek														|
Close()				Closes the current stream and releases any resources (such as sockets and file	|
				handles) associated with the current stream. Internally, this method is aliased	|
				to the Dispose() method; therefore, closing a stream is functionally 		|
				equivalent to disposing a stream.						|
Flush()				Updates the underlying data source or repository with the current state of the	|
				buffer and then clears the buffer. If a stream does not implement a buffer,	|
				this method does nothing.							|
Length				Returns the length of the stream in bytes.					|
Position			Determines the position in the current stream.					|
Read()				Reads a sequence of bytes (or a single byte) from the current stream and 	|
ReadByte()			advances the current position in the stream by the number of bytes read.	|
ReadAsync()													|
Seek()				Sets the position in the current stream.					|
SetLength()			Sets the length of the current stream.						|
Write()				Writes a sequence of bytes (or a single byte) to the current stream and 	|
WriteByte()			advances the current position in this stream by the number of bytes written.	|
WriteAsync()													|
----------------------------------------------------------------------------------------------------------------

Core Members of TextWriter
----------------------------------------------------------------------------------------------------------------
Member				Meaning in Life									|
----------------------------------------------------------------------------------------------------------------
Close()				This method closes the writer and frees any associated resources. In the 	|
				process, the buffer is automatically flushed (again, this member is		|
				functionally equivalent to calling the Dispose() method).			|
Flush()				This method clears all buffers for the current writer and causes any 		|
				buffered data to be written to the underlying devide; however, it does not	|
				close the writer.								|
NewLine				This property indicates the newline constant for the derived writer class.	|
				The default line terminator for the Windows OS is a carriage return, 		|
				followed by a line feed (\r\n).							|
Write()				This overloaded method writes data to the text stream without a newline		|
WriteAsync()			constant.									|
WriteLine()			This overloaded method writes data to the text stream with a newline constant.	|
WriteLineAsync()												|
----------------------------------------------------------------------------------------------------------------

TextReader Core Members
----------------------------------------------------------------------------------------------------------------
Member				Meaning in Life									|
----------------------------------------------------------------------------------------------------------------
Peek()				Returns the next available character (expressed as an integer) without		|
				actually changing the position of the reader. A value of -1 indicates you 	|
				are at the end of the stream.							|
Read()				Reads data from an input stream.						|
ReadAsync()													|
ReadBlock()			Reads a specified maximum number of characters from the current stream and	|
ReadBlockAsync()		writes the data to a buffer, beginning at a specified index.			|
ReadLine()			Reads a line of characters from the current stream and returns the data as a 	|
ReadLineAsync()			string (a null string indicates EOF).						|
ReadToEnd()			Reads all characters from the current position to the end of the stream and	|
ReadToEndAsync()		returns them as a single string.						|
----------------------------------------------------------------------------------------------------------------

BinaryWriter Core Members
----------------------------------------------------------------------------------------------------------------
Member				Meaning in Life									|
----------------------------------------------------------------------------------------------------------------
BaseStream			This read-only property provides access to the underlying stream used with 	|
				the BinaryWriter object.							|
Close()				This method closes the binary stream.						|
Flush()				This methods flushes the binary stream.						|
Seek()				This method sets the position in the current stream.				|
Write()				This method writes a value to the current stream.				|
----------------------------------------------------------------------------------------------------------------

BinaryReader Core Members
----------------------------------------------------------------------------------------------------------------
Member				Meaning in Life									|
----------------------------------------------------------------------------------------------------------------
BaseStream			This read-only property provides access to the underlying stream used with 	|
				the BinaryReader object.							|
Close()				This method closes the binary reader.						|
PeekChar()			This method returns the next available character without advancing the 		|
				position in the stream.								|
Read()				This method reads a given set of bytes or characters and stores them in the	|
				incoming array.									|
ReadXXXX()			The BinaryReader class defines numerous read methods that grab the next type	|
				from the stream (e.g., ReadBoolean(), ReadByte(), and ReadInt32()).		|
----------------------------------------------------------------------------------------------------------------

The term serialization describes the process of persisting (and possibly transferring) the state of an object
into a stream (e.g., file stream and memory stream). The persisted data sequence contains all the necessary information
you need to reconstruct (or deserialize) the state of the object for use later.

The CLR will account for all related objects to ensure that data is persisted correctly when an object is
serialized. This set of related objects is referred to as an object graph. Objects graph provide a simple way
to document how a set of items refer to each other.

To make an object available to .NET serialization services, all you need to do is decorate each related class
(or structure) with the [Serialization] attribute. If you determine that a given type has some member data that
should not (or perhaps cannot) participate in the serialization scheme, you can mark such fields with the 
[NonSerialized] attribute.

The BinaryFormatter type serializes your object's state to a stream using a compact binary format.
The SoapFormatter type persists an object's state as a SOAP message (the standard XML format for passing messages
to/from a SOAP-based web service).
Finally, if you want to persist a tree of objects as an XML document, you can use the XmlSerialize type.

Simple Object Access Protocol (SOAP) defines a standard process in which you can invoke methods in a platform-
and OS-neutral manner.

Select Attributes of the System.Xml.Serialization Namespace
----------------------------------------------------------------------------------------------------------------
.NET Attribute					Meaning in Life							|
----------------------------------------------------------------------------------------------------------------
[XmlAttribute]				You can use this .NET attribute on a public field or property in a 	|
					class to tell XmlSerializer to serialize the data as an XML attribute	|
					(rather than a subelement).						|
[XmlElement]				The field or property will be serialized as an XML element named as 	|
					you so choose.								|
[XmlEnum]				This attribute provides the element name of an enumeration member.	|	
[XmlRoot]				This attribute controls how the root element will be constructed	|
					(namespace and element name).						|
[XmlText]				The property or field will be serialized as XML text 			|
					(i.e., the content between the start tag and the end tag of the root	|
					element).								|
[XmlType]				This attribute provides the name and namespace of the XML type.		|
----------------------------------------------------------------------------------------------------------------

System.Runtime.Serialization Namespace Core Types
----------------------------------------------------------------------------------------------------------------
Type					Meaning in Life								|
----------------------------------------------------------------------------------------------------------------
ISerializable				You can implement this interface on a [Serializable] type to control	|
					its serialization and deserialization.					|
ObjectIDGenerator			This type generates IDs for members in an object graph.			|
[OnDeserialized]			This attribute allows you to specify a method that will be called 	|
					immediately after the object has been deserialized.			|
[OnDeserializing]			This attribute allows you to specify a method that will be called	|
					before the deserialization process.					|
[OnSerialized]				This attribute allows you to specify a method that willbe called 	|
					immediately after the object has been serialized.			|
[OnSerializing]				This attribute allows you to specify a method that will be called	|
					before the serialization process.					|
[OptionalField]				This attribute allows you to define a field on a type that can be	|
					missing from the specified stream.					|
[SerializationInfo]			In essence, this class is a property bag that maintains name-value	|
					pairs representing the state of an object during the serialization 	|
					process.								|
----------------------------------------------------------------------------------------------------------------

Objects that are marked [Serializable] have the option of implementing the ISerializable interface.

		Chapter 21 ADO.NET Part I: The Connected Layer

The .NET platform defines a number of namespaces that allow you to interact with relational database systems.
Collectively speaking, these namespaces are known as ADO.NET.

ADO - Active Data Objects

From a programmatic point of view, the bulk of ADO.NET is represented by a core assembly named System.Data.dll.

You can use the ADO.NET libraries in three conceptually unique manners: connected, disconnected, or through an ORM,
such as Entity Framework. 

When you use the connected layer, your code base explicitly connects to and disconnects
from the underlying data store. When you use ADO.NET in this manner, you typically interact with the data store
using connection objects, command objects, and data reader objects.

The disconnected layer allows you to manipulate a set of DataTable objects (contained within a DataSet) that
functions as a client-side copy of the external data. When you obtain a DataSet using a related data adapter object,
the connection is automatically opened and closed on your behalf. As you would guess, this approach helps free up
connections for other callers quickly and goes a long way toward increasing the scalability of your systems.
After a caller receives a DataSet, it is able to traverse and manipulate the contents without incurring the cost
of network traffic. Also, if the caller wants to submit the changes back to the data store, the data adapter
(in conjunction with a set of SQL statements) is used to update the data source; at this point the connection
is reopened for the database updates to occur and then closed again immediately.

Using Entity Framework (EF), you are able to interact with a relational database using client-side objects that
encapsulates a number of low-level database specifics from view. As well, the EF programming model allows you
to interact with relational databases using strongly typed LINQ queries, using the grammar of LINQ to Entities.

ADO.NET does not provide a single set of objects that communicate with multiple database management systems (DBMSs).
Rather, ADO.NET supports multiple data providers, each of which is optimized to interact with a specific DBMS.
The first benefit of this approach is that you can program a specific data provider to access any unique features
of a particular DBMS. The second benefit is that a specific data provider can connect directly to the underlying
engine of the DBMS in question without an intermediate mapping layer standing between the tiers.

The Core Object of an ADO.NET Data Provider
----------------------------------------------------------------------------------------------------------------
Type of Object		Base Class	Relevant Interfaces	Meaning in Life					|
----------------------------------------------------------------------------------------------------------------
Connection		DbConnection	IDbConnection		Provides the ability to connect to and		|
								disconnect from the data store. Connection	|
								objects also provide access to a related	|
								transaction object.				|
Command			DbCommand	IDbCommand		Represents a SQL query or a stored procedure.	|
								Command objects also provide access to the	|
								provider's data reader object.			|
DataReader		DbDataReader	IDataReader,		Provides forward-only, read-only access to data	|
					IDataRecord		using a server-side cursor.			|
DataAdapter		DbDataAdapter	IDataAdapter,		Transfers DataSets between the caller and the 	|
					IDbDataAdapter		data store. Data adapters contain a connection	|
								and a set of four internal command objects	|
								used to select, insert, update, and delete	|
								information from the data store.		|
Parameter		DbParameter	IDataParameter,		Represents a named parameter within a 		|
					IDbDataParameter	parameterized query.				|
Transaction		DbTransaction	IDbTransaction		Encapsulates a database transaction.		|
----------------------------------------------------------------------------------------------------------------

Select Additional ADO.NET-Centric Namespaces
----------------------------------------------------------------------------------------------------------------
Namespace				Meaning in Life								|
----------------------------------------------------------------------------------------------------------------
Microsoft.SqlServer.Server		This namespace provides types that facilitate CLR and SQL Server 2005	|
					and later integration services.						|
System.Data				This namespace defines the core ADO.NET types used by all data		|
					providers, including common interfaces and numerous types that 		|
					represent the disconnected layer (e.g., DataSet and DataTable).		|
System.Data.Common			This namespace contains types shared between all ADO.NET data 		|
					providers, including the common abstract base classes.			|
System.Data.Sql				This namespace contains types that allow you to discover Microsoft	|
					SQL Server instances installed on the current local network.		|
System.Data.SqlTypes			This namespace contains native data types used by Microsoft SQL Server.	|
					You can always use the corresponding CLR data types, but the SqlTypes	|
					are optimized to work with SQL Server (e.g., if your SQL Server		|
					database contains an integer value, you can represent it using either	|
					int or SqlTypes.SqlInt32).						|
----------------------------------------------------------------------------------------------------------------

Core Members of the System.Data Namespace					
----------------------------------------------------------------------------------------------------------------
Type					Meaning in Life								|
----------------------------------------------------------------------------------------------------------------
Constraint				Represents a constraint for a given DataColumn object.			|
DataColumn				Represents a single column within a DataTable object.			|
DataRelation				Represents a parent-child relationship between two DataTable objects.	|
DataRow					Represents a single row within a DataTable object.			|
DataSet					Represents an in-memory cache of data consisting of any number of	|
					interrelated DataTable objects.						|
DataTable				Represents a tabular block of in-memory data.				|
DataTableReader				Allows you to treat a DataTable as a fire-hose cursor (forward only,	|
					read-only data access).							|
DataView				Represents a customized view of a DataTable for sorting, filtering,	|
					searching, editing, and navigation.					|
IDataAdapter				Defines the core behavior of a data adapter object.			|
IDataParameter				Defines the core behavior of a parameter object.			|
IDataReader				Defines the core behavior of a data reader object.			|
IDbCommand				Defines the core behavior of a command object.				|
IDbDataAdapter				Extends IDataAdapter to provide additional functionality of a data	|
					adapter object.								|
IDbTransaction				Defines the core behavior of a transaction object.			|
----------------------------------------------------------------------------------------------------------------

When you refer to a connection object under ADO.NET, you're actually referring to a specific DbConnection-derived type;
there is no class literally named Connection. The same idea holds true for a command object, data adapter object, and
so forth.

The IDbConnection type is implemented by a data provider's connection object. This interface defines a set of members
used to configure a connection to a specific data store.

You can use the members defined by IDbTransaction to interact programmatically with a transactional session and 
the underlying data store.

IDbCommand interface allows programmatic manipulation of SQL statements, stored procedures, and parameterized queries.

You use data adapters to push and pull DataSets to and from a given data store.

DbCommand - the abstract base class for all command classes.
DbConnection - the abstract base class for all connection classes.
DbDataAdapter - the abstract base class for all data adapter classes.
DbDataReader - the abstract base class for all data reader classes.
DbParameter - the abstract base class for all parameter classes.
DbTransaction - the abtsract base class for all transaction classes.

Members of the DbConnection Type
----------------------------------------------------------------------------------------------------------------
Member					Meaning in Life								|
----------------------------------------------------------------------------------------------------------------
BeginTransaction()			You use this method to begin a database transaction.			|
ChangeDatabase()			You use this method to change the database on an open connection.	|
ConnectionTimeout			This read-only property returns the amount of time to wait while	|
					establishing a connection before terminating and generating an error	|
					(the default value is 15 seconds). If you would like to change the	|
					default specify a Connect Timeout segment in the connection string	|
					(e.g., Connect Timeout = 30).						|
Database				This read-only property gets the name of the database maintained by the	|
					connection object.							|
DataSource				This read-only property gets the location of the database maintained by	|
					the connection object.							|
GetSchema()				This method returns a DataTable object that contains schema information	|
					from the data source.							|
State					This read-only property gets the current state of the connection, which	|
					is represented by the ConnectionState enumeration.			|
----------------------------------------------------------------------------------------------------------------

The Microsoft-supplied ADO.NET data providers support connection string builder objects, which allow you 
to establish the name-value pairs using strongly typed properties.

Membes of the DbCommand Type
----------------------------------------------------------------------------------------------------------------
Member					Meaning in Life								|
----------------------------------------------------------------------------------------------------------------
CommandTimeout				Gets or sets the time to wait while executing the command before	|
					terminating the attempt and generating an error. The default is 	|
					30 seconds.								|
Connection				Gets or sets the DbConnection used by this instance of the DbCommand.	|
Parameters				Gets the collection of DbParameter objects used for a 			|
					parameterized query.							|
Cancel()				Cancels the execution of a command.					|
ExecuteReader()				Executes a SQL query and returns the data provider's DbDataReader	|
					objects, which provides forward-only, read-only access for the result	|
					of the query.								|
ExecuteNonQuery()			Executes a SQL nonquery(e.g., an insert, update, delete,		|
					or create table).							|
ExecuteScalar()				A lightweight version of the ExecuteReader() method that was designed	|
					specifically for singleton queries (e.g., obtaining a record count).	|
Prepare()				Creates a prepared (or compiled) version of the command on the data	|
					source. As you might know, a prepared query executes slightly faster	|
					and is useful when you need to execute the same query multiple times	|
					(typically with different parameters each time).			|
----------------------------------------------------------------------------------------------------------------

You obtain data reader objects from the command object using a call to ExecuteReader(). The data reader represents
the current record it has read from the database. The data reader has an indexer method (e.g., [] syntax in C#)
that allows you to access a column in the current record. You can access the column either by name or by
zero-based integer.

Always remember that a data reader can process only SQL Select statements; you cannot use them to modify an existing
database table using Insert, Update, or Delete requests.

Technically speaking, a nonquery is a SQL statement that does not return a result set. Thus, Select statements
are queries, while Insert, Update, and Delete statements are not. Given this, ExecuteNonQuery() returns an int
that represents the number of rows affected, not a new set of records.

As you might know, building a SQL statement using string concatenation can be risky from a security point of view
(think: SQL injection attack). The preferred way to build command text is to use a parameterized query.

You can use a parameterized query to treat SQL parameters as objects, rather than as a simple blob of text.
Treating SQL queries in a more object-oriented manner helps reduce the number of typos (given strongly typed 
properties); plus, parameterized queries typically execute much faster than a literal SQL string because they are 
parsed exactly once (rather that each time the SQL string is assigned to the CommandText property).
Parameterized queries also help protect against SQL injection attacks (as well-known data access security issue).

Key Members of the DbParameter Type
----------------------------------------------------------------------------------------------------------------
Property				Meaning in Life								|
----------------------------------------------------------------------------------------------------------------
DbType					Gets or sets the native data type of the parameter, represented as a	|
					CLR data type								|
Direction				Gets or sets whether the parameter is input-only, output-only, 		|
					bidirectional, or a return value parameter				|
IsNullable				Gets or sets whether the parameter accepts null values			|
ParameterName				Gets or sets the name of the DbParameter				|
Size					Gets or sets the maximum parameter size of the data in bytes; this is	|
					useful only for textual data						|
Value					Gets or sets the value of the parameter					|
----------------------------------------------------------------------------------------------------------------

Recall that a stored procedure is a named block of SQL code stored in the database. You can construct stored procedures
so they return a set of rows or scalar types or do anything else that makes sense (e.g., insert, update, or delete);
you can also have them take any number of optional parameters. The end result is a unit of work that behaves like
a typical function, except that it is located on a data store rather than a binary business object.

A transaction is a set of database operations that must either all work or all fails as a collective unit.
If any part of the transaction fails, the entire operation is rolled back to the original state. On the other hand,
if all steps succeed, the transaction is committed.

A - atomic (all or nothing)
C - consistent (data remains stable throughout the transaction)
I - isolated (transactions do not step on each other's feet)
D - durable (transaction are saved and logged)

The IsolationLevel property of a transaction object allows you to specify how aggressively a transaction should be
guarded against the activities of other parallel transactions. By default, transactions are isolated completely 
until committed.

Beyond the members defined by the IDbTransaction interface, the SqlTransaction type defines an additional member
named Save(), which allows you to define save points. This concept allows you to roll back a failed transaction
up until a named point, rather than rolling back the entire transaction.

		Chapter 22 ADO.NET Part II: The Disconnected Layer

Properties of the DataSet
----------------------------------------------------------------------------------------------------------------
Property				Meaning in Life								|
----------------------------------------------------------------------------------------------------------------
CaseSensitive				Indicates whether string comparisons in DataTable objects are case	|
					sensitive (or not). The default is false (string comparisons are not	|
					case sensitive by default).						|
DataSetName				Represents the friendly name of this DataSet. Typically, you establish	|
					this value as a constructor parameter.					|
EnforceConstraints			Gets or sets a value indicating whether constraint rules are followed	|
					when attempting any update operations (the default is true).		|
HasErrors				Gets a value indicating whether there are errors in any of the rows in	|
					any of the DataTables of the DataSet.					|
RemotingFormat				Allows you to define how the DataSet should serialize its content	|
					(binary or XML, which is the default).					|
----------------------------------------------------------------------------------------------------------------

Select Methods of the DataSet
----------------------------------------------------------------------------------------------------------------
Methods					Meaning in Life								|
----------------------------------------------------------------------------------------------------------------
AcceptChanges()				Commits all the changes made to this DataSet since it was loaded or	|
					the last time AcceptChanges() was called.				|
Clear()					Completely clears the DataSet data by removing every row in each	|
					DataTable.								|
Clone()					Clones the structure, but not the data, of the DataSet, including all	|
					DataTables, as well as all relations and any constraints.		|
Copy()					Copied both the structure and data for this DataSet.			|
GetChanges()				Returns a copy of the DataSet containing all changes made to it since	|
					it was last loaded or since AcceptChanges() was called. This method	|
					is overloaded so that you can get just the new rows, just the modified	|
					rows, or just the deleted rows.						|
HasChanges()				Gets a value indicating whether the DataSet has changes, including new,	|
					deleted, or modified rows.						|
Merge()					Merges this DataSet with a specified DataSet.				|
ReadXml()				Allows you to define the structure of a DataSet object and populate it	|
					with data, based on XML schema and data read from a schema.		|
RejectChanges()				Rolls back all the changes made to this DataSet since it was created or	|
					since the last time AcceptChanges() was called.				|
WriteXml()				Allows you to write out the contents of a DataSet into a valid stream.	|
----------------------------------------------------------------------------------------------------------------

A GUID (aka a globally unique identifier) is a statically unique 128-bit number.

Properties of the DataColumn
----------------------------------------------------------------------------------------------------------------
Property				Meaning in Life								|
----------------------------------------------------------------------------------------------------------------
AllowDBNull				You use this property to indicate whether a row can specify null values	|
					in this column. The default value is true.				|
AutoIncrement				You use these properties to configure the autoincrement behavior for a	|
AutoIncrementSeed			given column. This can be helpful when you want to ensure unique values	|
AutoIncrementStep			in a given DataColumn (such as a primary key). By default, a DataColumn	|
					does not support autoincrement behavior.				|
Caption					This property gets or sets the caption you want to display for this	|
					column. This allows you to define a user-friendly version of a literal	|
					database column name.							|
ColumnMapping				This property determines how a DataColumn is represented when a DataSet	|
					is saved as an XML document using the DataSet.WriteXml() method.	|
					You can specify that the data column should be written out as an XML	|
					element, an XML attribute, simple text content, or ignored altogether.	|
ColumnName				This property gets or sets the name of the column in the Columns	|
					collection (meaning how it is represented internally by the DataTable).	|
					If you do not set the ColumnName explicitly, the default values are 	|
					Column with (n+1) numerical suffixes (e.g., Column1, Column2, Column3).	|
DataType				This property defines the data type (e.g., Boolean, string, or float)	|
					stored in the column.							|
DefaultValue				This property gets or sets the default value assigned to this column	|
					when you insert new rows.						|
Expression				This property gets or sets the expression used to filter rows,		|
					calculate a column's value, or create an aggregate column.		|
Ordinal					This property gets the numerical position of the column in the		|
					Columns collection maintained by the DataTable.				|
ReadOnly				This property determines whether the column is read-only, once a row	|
					has been added to the table. The default is false.			|
Table					This property gets the DataTable that contains this DataColumn.		|
Unique					This property gets or sets a value indicating whether the value in	|
					each row of the column must be unique or if repeating values are 	|
					permissible. If you assign a column a primary key constraint, then 	|
					you must set the Unique property to true.				|
----------------------------------------------------------------------------------------------------------------

Key Members of the DataRow Type
----------------------------------------------------------------------------------------------------------------
Members					Meaning in Life								|
----------------------------------------------------------------------------------------------------------------
HasErrors()				The HasErrors property returns a Boolean value indicating whether	|
GetColumnsInError()			there are errors in a DataRow. If so, you can use the			|
GetColumnError()			GetColumnsInError() method to obtain the offending columns and		|
ClearErrors()				GetColumnError() to obtain the error description. Similarly, you can	|
RowError				use the ClearErrors() method to remove each error listing for the row.	|
					The RowError property allows you to configure a textual description	|
					of the error for a given row.						|
ItemArray				This property gets or sets all the column values for this row using	|
					an array of objects.							|
RowState				You use this property to pinpoint the current state of the DataRow	|
					in the DataTable containing the DataRow, using values of the RowState	|
					enumeration (e.g., a row can be flagged as new, modified, unchanged,	|
					or deleted).								|
Table					You use this property to obtain a reference to the DataTable		|
					containing this DataRow.						|
AcceptChanges()				These methods commit or reject all changes made to this row since the	|
RejectChanges()				last time AcceptChanges() was called.					|
BeginEdit()				These methods begin, end, or cancel an edit operation on a DataRow	|
EndEdit()				object.									|
CancelEdit()													|
Delete()				This method marks a row you want to remove when the AcceptChanges()	|
					method is called.							|
IsNull()				This method gets a value indicating whether the specified column	|
					contains the null value.						|
----------------------------------------------------------------------------------------------------------------

You cannot create a direct instance of the DataRow type because there is no public constructor.
If you pass the DataRow's indexer method an invalid column name or ordinal position, you will receive a runtime
exception.

Values of the DataRowState Enumeration
----------------------------------------------------------------------------------------------------------------
Value					Meaning in Life								|
----------------------------------------------------------------------------------------------------------------
Added					The row has been added to a DataRowCollection, and AcceptChanges()	|
					has not been called.							|
Deleted					The row has been marked for deletion using the Delete() method of the	|
					DataRow, and AcceptChanges() has not been called.			|
Detached				The row has been created but is not part of any DataRowCollection.	|
					A DataRow is in this state immediately after it has been created, 	|
					but before it is added to a collection. It is also in this state	|
					if it has been removed from a collection.				|
Modified				The row has been modified, and AcceptChanges() has not been called.	|
Unchanged				The row has not changed since AcceptChanges() was last called.		|
----------------------------------------------------------------------------------------------------------------

Values of the DataRowVersion Enumeration
----------------------------------------------------------------------------------------------------------------
Value					Meaning in Life								|
----------------------------------------------------------------------------------------------------------------
Current					This represents the current value of a row, even after changes has	|
					been made.								|
Default					This is the default version of DataRowState. For a DataRowState value	|
					of Added, Modified, or Deleted, the default version is Current.		|
					For a DataRowState value of Detached, the version is Proposed.		|
Original				This represents the value first inserted into a DataRow or the value	|
					the last time AcceptChanges() was called.				|
Proposed				This is the value of a row currently being edited because of a call	|
					to BeginEdit().								|
----------------------------------------------------------------------------------------------------------------

Key Members of the DataTable Type
----------------------------------------------------------------------------------------------------------------
Member					Meaning in Life								|
----------------------------------------------------------------------------------------------------------------
CaseSensitive				Indicates whether string comparisons within the table are case		|
					sensitive. The default value is false.					|
ChildRelations				Returns the collection of child relations for this DataTable (if any).	|
Constraints				Gets the collection of constraints maintained by the table.		|
Copy()					A method that copies the schema and data of a given DataTable into	|
					a new instance.								|
DataSet					Gets the DataSet that contains this table (if any).			|
DefaultView				Gets a customized view of the table that might include a filtered view	|
					or a cursor position.							|
ParentRelations				Gets the collection of parent relations for this DataTable.		|
PrimaryKey				Gets or sets an array of columns that function as primary key for the	|
					data table.								|
TableName				Gets or sets the name of the table. This same property might also be	|
					specified as a constructor parameter.					|
----------------------------------------------------------------------------------------------------------------

Core Members of the DbDataAdapter Class
----------------------------------------------------------------------------------------------------------------
Member					Meaning in Life								|
----------------------------------------------------------------------------------------------------------------
Fill()					Executes a SQL SELECT command (as specified by the SelectCommand	|
					property) to query the database for data and loads the data into 	|
					a DataTable.								|
SelectCommand				Establishes the SQL commands that you will issue to the data store	|
InsertCommand				when the Fill() and Update() methods are called.			|
UpdateCommand													|
DeleteCommand													|
Update()				Executes SQL INSERT, UPDATE, and DELETE commands (as specified by the	|
					InsertCommand, UpdateCommand, and DeleteCommand properties) to persist	|
					DataTable change to the database.					|
----------------------------------------------------------------------------------------------------------------

		Chapter 23 ADO.NET Part III: Entity Framework

The strongly typed classes are called entities. Entities are a conceptual model of a physical database that maps
to your business domain. Formally speaking, this model is termed an entity data model (EDM).
The EDM is a client-side set of classes that are mapped to a physical database by Entity Framework convention
and configuration. You are free to restructure your entity classes to fit your needs, and the EF runtime will map
your unique names to the correct database schema.

The EF API sits on top of the existing ADO.NET infrastructure.

The DbContext class represents a combination of the Unit of Work and Repository patterns that can be used to query
from a database and group together changes that will be written back as a single unit of work.
DbContext provides a number of core services to child classes, including the ability to save all changes (which
results in a database update), tweak the connection string, delete objects, call stored procedures, and handle
other fundamental details.

Common Members of DbContext
----------------------------------------------------------------------------------------------------------------
Member of DbContext			Meaning in Life								|
----------------------------------------------------------------------------------------------------------------
DbContext				Constructor used by default in the derived context class. The string	|
					parameter is either the database name or the connection string		|
					stored in the *.config file.						|
Entry					Retrieves the System.Data.Entity.Infrastructure.DbEntityEntry object	|
Entry<TEntity>				providing access to information and the ability to perform actions	|
					on the entity.								|
GetValidationErrors			Validates tracked entries and returns a collection of 			|
					System.Data.Entity.Validation.DbEntityValidationResults.		|
SaveChanges				Saves all changes made in this context to the database. Returns the	|
SaveChangesAsync			number of affected entities.						|
Configuration				Provides access to the configuration properties of the context.		|
Database				Provides a mechanism for creation/deletion/existence checks for the	|
					underlying database, executes stored procedures and raw SQL statements	|	
					against the underlying data store, and exposes transaction 		|
					functionality.								|
----------------------------------------------------------------------------------------------------------------

Events in DbContext
----------------------------------------------------------------------------------------------------------------
Events of DbContext			Meaning in Life								|
----------------------------------------------------------------------------------------------------------------
ObjectMaterialized			Fires when a new entity object is created from the data store as part	|
					of a query or load operation						|
SavingChanges				Occurs when changes are being saved to the data store but prior to the	|
					data being persisted							|
----------------------------------------------------------------------------------------------------------------

The DbContext class provides the core functionality when working with EF Code First.

To add tables into your context, you add a DbSet<T> for each table in your object model. To enable lazy loading,
the properties in the context need to be virtual.

Common Members of DbSet<T>
----------------------------------------------------------------------------------------------------------------
Member of DbSet<T>			Meaning in Life								|
----------------------------------------------------------------------------------------------------------------
Add					Allows you to insert a new object (or range of objects) into the	|
AddRange				collection. They will be marked with the Added state and will be	|
					inserted into the database when SaveChanges (or SaveChangesAsync) is	|
					called on the DbContext.						|
Attach					Associates an object with the DbContext. This is commonly used in	|
					disconnected applications like ASP.NET/MVC.				|
Create					Creates a new instance of the specified entity type.			|
Create<T>													|
Find					Finds a data row by the primary key and returns an object representing	|
FindAsync				that row.								|
Remove					Marks an object (or range of objects) for deletion.			|
RemoveRange													|
SqlQuery				Creates a raw SQL query that will return entities in this set.		|
----------------------------------------------------------------------------------------------------------------

The DbContext automatically tracks the state for any object within its context.

Entity State Enumeration Values
----------------------------------------------------------------------------------------------------------------
Value					Meaning in Life								|
----------------------------------------------------------------------------------------------------------------
Detached				The object exists but is not being tracked. An entity is in this	|
					state immediately after it has been created and before it is added	|
					to the object context.							|
Unchanged				The object has not been modified since it was attached to the context	|
					or since the last time that the SaveChanges() method was called.	|
Added					The object is new and has been added to the object context, and the	|
					SaveChanges() method has not been called.				|
Deleted					The object has been deleted from the object context but not yet removed	|
					from the data store.							|
Modified				One of the scalar properties on the object was modified, and the	|
					SaveChanges() method has not been called.				|
----------------------------------------------------------------------------------------------------------------

CRUD - create, read, update, delete operations

You can change the entity name, as well as property names of the entity, by using special .NET attributes 
referred to as data annotations.

All the designer-generated classes have been declared with the partial keyword, which allows you to implement
a class across multiple C# code files. This is especially useful when working with the EF programming model because
it means you can add additional methods to your entity classes that help you model your business domain better.

Remember, that you are hitting a database each time you apply a LINQ query to the object context!
Recall that when you want to obtain an independent copy of data, which can be the target of new LINQ queries,
you want to use immediate execution with the ToList<T>(), ToArray<T>(), or ToDictionary<K, V>() extension methods
(among others).

Navigation properties allow you to capture JOIN operations in the Entity Framework programming model (without the 
need to author complex SQL statements). To account for these foreign key relationships, each class in your model
contains virtual properties that connect your classes together.

There are three ways that EF loads data into models. Lazy and Eager fetching are based on settings on the context,
and the third, Explicit, is developer controlled.

Lazy loading - the virtual modified allows EF to lazy load the data. This means that EF loads the bare minimum 
for each object and then retrieves additional details when properties are asked for in code.

Eager loading - sometimes you want to load all related records.

Explicit loading - loads a collection or class that is referenced by a navigation property. If lazy loading is
disabled, then you need to either eager load related objects or explicitly load them.

	Chapter 24 Introducing LINQ to XML

The LINQ to XML API is an alternative manner to create, manipulate, and query XML documents, which uses a much more
functional approach that the System.Xml DOM model.

Select Members of the System.Xml.Linq Namespace
----------------------------------------------------------------------------------------------------------------
Member of System.Xml.Linq		Meaning in Life								|
----------------------------------------------------------------------------------------------------------------
XAttribute				Represents an XML attribute on a given XML element.			|
XCData					Represents a CDATA section in the XML document. Information in a CDATA	|
					section represents data in an XML document that must be included but	|
					does not conform to the rules of XML grammars (for example, 		|
					script code).								|
XComment				Represents an XML document.						|
XDeclaration				Represents the opening declaration of an XML document.			|
XDocument				Represents the entirety of an XML document.				|
XElement				Represents a given element within an XML document, including the root	|
					element.								|
XName					Represents the name of an XML element or XML attribute.			|
XNamespace				Represents an XML namespace.						|
XNode					Represents the abstract concept of a node (element, comment,		|
					document type, processing instruction, or text node) in the XML tree.	|
XProcessingInstruction			Represents an XML processing instruction.				|
XStreamingElement			Represents elements in an XML tree that support deferred streaming	|
					output.									|
----------------------------------------------------------------------------------------------------------------

Select Members of the LINQ to XML Extensions Class
----------------------------------------------------------------------------------------------------------------
Member of Extensions			Meaning in Life								|
----------------------------------------------------------------------------------------------------------------
Ancestors<T>()				Returns a filtered collection of elements that contains the		|
					ancestors of every node in the source collection.			|
Attributes()				Returns a filtered collection of the attributes of every element	|
					in the source collection.						|
DescendantNodes<T>()			Returns a collection of the descendant nodes of every document and	|
					element in the source collection.					|
Descendants<T>				Returns a filtered collection of elements that contains the		|
					descendant elements of every element and document in the source		|
					collection.								|
Elements<T>				Returns a collection of the child elements of every element and 	|
					document in the source collection.					|
Nodes<T>				Returns a collection of the child nodes of every document and element	|
					in the source collection.						|
Remove()				Removes every attribute in the source collection from its parent	|
					element.								|
Remove<T>()				Removes all occurences of a given node from the source collection.	|
----------------------------------------------------------------------------------------------------------------

	Chapter 25 Introducing Windows Communication Foundation

Windows Communication Foundation (WCF) is the name of the API designed specifically for the process of building
distributed systems. WCF provides a single, unified, and extendable programming object model that you can use
to interact with a number of diverse distributed technologies.

The Windows operating system has historically provided many APIs for building distributed systems. While it is
true that most people consider a distributed system to involve at least two networked computers, this term in the
broader sense can refer to two executables that need to exchange data, even if they happen to be running on the
same physical machine. Using this definition, selecting a distributed API for your current programming task
typically involves asking the following pivotal question:
   Will this system be used exclusively in house, or will external users require access to the application's 
functionality?
If you build a distributed system for in-house use, you have a far greater chance of ensuring that each connected
computer is running the same operating system and using the same programming framework (e.g., .NET, COM, or the
Java platform). Running in-house systems also means that you can leverage your existing security system for
purposes of authentication, authorization, and so forth. In this situation, you might be willing to select a
particular distributed API that will tie you to a specific operating system/programming framework for the 
purpose of performance.
In contrast, if you build a system that others must reach from outside of your walls, you have a whole other set
of issues to contend with. First, you will most likely not be able to dictate to external users which 
operating system(s) they can use, which programming framework(s) they can use, or how they configure their
security settings.
Second, if you happen to work for a larger company or in a university setting that uses numerous operating
systems and programming technologies, an in-house application suddenly faces the same challenges as an
outward-facing application. In either of these cases, you need to limit yourself to a more flexible distributed
API to ensure the furthest reach of your application.

WCF (and the technologies it encompasses) has nothing to do with building an HTML-based web site. While it is
true that web applications can be considered distributed because two machines are typically involved in the 
exchange, WCF is about establishing connections between machines to share the functionality of remote components-
not for displaying HTML in a web browser.

WSDL - Web Sevice Description Language

Consider the following list of major WCF features:
- support for strongly typed as well as untyped messages. This approach allows .NET applications to share custom
types efficiently, while software created using other platforms (such as Java) can consume streams of loosely
typed XML.
- support for several bindings (e.g., raw HTTP, TCP, MSMQ, WebSockets, named pipes, and so on) allows you to choose
the most appropriate plumbing to transport message data.
- support for the latest-and-greatest web service specifications (WS-*).
- a fully integrated security model encompassing both native Windows/.NET security protocols and numerous
neutral-security techniques, as well as support for one-way or stateless message.
- support for session-like state management techniques, as well as support for one-way or stateless messages.

Yet another benefit of WCF is that it is based on the design principles established by service-oriented
architecture (SOA). SOA is a way to design a distributed system where several autonomous services work in 
conjunction by passing messages across boundaries (either networked machines or two processes on the same machine)
using well-defined interfaces.

The team that designed WCF observed the four tenets of SOA design principles.

Tenet 1: Boundaries are Explicit
This tenet reiterates that the functionality of a WCF service is expressed using well-defined interfaces
(e.g., descriptions of each member, its parameters, and its return values). The only way that an external caller
can communicate with a WCF service is through the interface, and the external caller remains blissfully unaware
of the underlying implementation details.

Tenet 2: Services are Autonomous
The term autonomous entities refers to the fact that a given WCF service is (as much as possible) an island unto
itself. An autonomous service should be implemented with regard to version, deployment, and installation issues.
To help promote this tenet, you can fall back on a key aspect of interface-based programming. Once an interface
is in production, it should never be changed (or you will risk breaking existing clients). When you need to
extend the functionality of your WCF service, you author new interfaces that model the desired functionality.

Tenet 3: Services Communicate via Contract, Not Implementation
The third tenet is yet another by-product of interface-based programming. The implementation details of a 
WCF service (e.g., the language it was written in, how it accomplishes its work, etc.) are of no concern to the
external caller. WCF clients interact with services solely through their exposed public interfaces.

Tenet 4: Service Compatability is Based on Policy
Because CLR interface provide strongly typed contracts for all WCF clients (and can also be used to generate
a related WSDL document based on your choice of binding), it is important to realize that interfaces and WSDL 
alone are not expressive enough to detail aspects of what the service is capable of doing. Given this, SOA allows
you to define policies that further qualify the semantics of the service (e.g., the expected security 
requirements used to talk to the service). Using these policies, you can basically separate the low-level syntactic
description of your service (the exposed interface) from the sematics details of how they work and how they need
to be invoked.

WCF is the recommended API whether you want to build an in-house application using TCP protocols, move data between
programs on the same machine using named pipes, or expose data to the world at large using HTTP-based protocols.

Core WCF Assemblies
----------------------------------------------------------------------------------------------------------------
Assembly				Meaning in Life								|
----------------------------------------------------------------------------------------------------------------
System.Runtime.Serialization.dll	This core assembly defines namespaces and types that you can use	|
					for serializing and deserializing objects in the WCF framework.		|
System.ServiceModel.dll			This core assembly contains the types used to build any sort of WCF	|
					application.								|
----------------------------------------------------------------------------------------------------------------

Core WCF Namespaces
----------------------------------------------------------------------------------------------------------------
Namespace				Meaning in Life								|
----------------------------------------------------------------------------------------------------------------
System.Runtime.Serialization		This defines many types you use to control how data is serialized	|
					and deserialized within the WCF framework.				|
System.ServiceModel			This primary WCF namespace defines binding and hosting types, as well	|
					as basic security and transactional types.				|
System.ServiceModel.Configuration	This defines numerous types that provide programmatic access		|
					to WCF configuration file.						|
System.ServiceModel.Description		This defines types that provide an object model to the addresses, 	|
					bindings, and contracts defined within WCF configuration files.		|
System.ServiceModel.MsmqIntegration	This contains types to integrate with the MSMQ service.			|
System.ServiceModel.Security		This defines numerous types to control aspects of the WCF security	|
					layers.									|
----------------------------------------------------------------------------------------------------------------

The App.config file of the WCF Sevice Library project is also useful because it shows you the bare-bones
settings used to configure a WCF host application. In fact, you can copy and paste much of this code into the
configuration file of your production service.

When you build a WCF distributed system, you will typically do so by creating the following three interrelated
assemblies:
- the WCF Service assembly: this *.dll contains the classes and interfaces that represent the overall 
functionality you want to expose to external caller
- the WCF Service host: this software module is the entity that hosts your WCF service assembly
- the WCF client: this is the application that accesses the service's functionality through an intervening
proxy

The WCF Service assembly is a .NET class library that contains a number of WCF contracts and their implementation.
The key difference is that the interface contracts are adorned with various attributes that control data type 
representation, how the WCF runtime interacts with the exposed types, and so forth.
The second assembly, the WCF Service host, can be literally any .NET executable. WCF was set up so that you can 
expose services easily from any type of application (e.g., Windows Forms, a Windows service, and 
WPF applications). When you build a custom host, you use the ServiceHost type and possibly a related 
*.config file. The latter contains details regarding the server-side plumbing you want to use. However, if you
use IIS as the host for your WCF service, you don't need to build a custom host programmatically because
IIS will use the ServiceHost type behind the scenes.
The final assembly represents the client that makes calls into the WCF service. This client can be any type of
.NET application. Similar to the host, client application typically use a client-side *.config file that
defines the client-side plumbing. You should also be aware that you can easily have a client application
written in another framework (e.g., Java) if you build your WCF service using HTTP-based bindings.

Hosts and clients communicate with each other by agreeing on the ABCs, a friendly mnemonic for remembering
the core building blocks of a WCF application address, bindings, and contract, defined as follows:
- address: describes the location of the service. In code, you represent this with a System.Uri type;
however, you typically store the value in *.config file
- binding: WCF ships with a many different bindings that specify network protocols, encoding mechanisms,
and the transport layer
- contract: provides a description of each method exposed from the WCF service

Interfaces that represent a WCF contract are called service contracts. The classes (or structures) that
implement them are called service types.

A WCF binding can specify the following characteristics:
- the transport layer used to move data (HTTP, MSMQ, named pipes, REST, WebSockets, and TCP)
- the channels used by the transport (one-way, request-reply, and duplex)
- the encoding mechanism used to deal with the data itself (e.g., XML and binary)
- any supported web service protocols (if permitted by the binding), such as WS-Security, WS-Transaction,
WS-Reliability, and so on

The HTTP-Centric WCF Bindings
----------------------------------------------------------------------------------------------------------------
Binding Class			Binding Element			Meaning in Life					|
----------------------------------------------------------------------------------------------------------------
BasicHttpBinding		<basicHttpBinding>		You use this to build a WS-Basic Profile - 	|
								conformant WCF service. This binding uses HTTP	|
								as the transport and Text/XML as the default	|
								message encoding.				|
WSHttpBinding			<wsHttpBinding>			This is similar to BasicHttpBinding but 	|
								provides more web service features. This binding|
								adds support for transactions, reliable 	|
								messaging, and WS-Addressing.			|
WSDualHttpBinding		<wsDualHttpBinding>		This is similar to WSHttpBinding but intended	|
								for use with duplex contracts (e.g., service	|
								and client can send messages back and forth).	|
								This binding supports only SOAP security and	|
								requires reliable messaging.			|
WSFederationHttpBinding		<wsFederationHttpBinding>	This is a secure and interoperable binding that	|
								supports the WS-Federation protocol, enabling	|
								organizations that are in a federation to 	|
								authenticate and authorize users efficiently.	|
----------------------------------------------------------------------------------------------------------------

The TCP-Centric WCF Bindings
----------------------------------------------------------------------------------------------------------------
Binding Class			Binding Element			Meaning in Life					|
----------------------------------------------------------------------------------------------------------------
NetNamedPipeBinding		<netNamedPipeBinding>		Serves as a secure, reliable, optimized		|
								binding for on-the-same-machine communication	|
								between .NET applications.			|
NetPeerTcpBinding		<netPeerTcpBinding>		Provides a secure binding for P2P network	|
								applications.					|
NetTcpBinding			<netTcpBinding>			Serves as a secure and optimized binding	|
								suitable for cross-machine communication	|
								between .NET applications.			|
----------------------------------------------------------------------------------------------------------------

The exact format of the WCF address will differ based on your choice of binding (HTTP based, named pipes, TCP based,
or MSMQ based). From a high level, WCF addresses can specify the following bits of information:
- Scheme: the transport protocol (e.g., HTTP)
- MachineName: the fully qualified domain of the machine
- Port: this is optional in many cases; for example, the default for HTTP bindings is port 80
- Path: the path to the WCF service

scheme://<MachineName>[:Port]/Path
http://localhost:8080/MyWCFService

Various Named Properties of the [ServiceContract] Attribute
----------------------------------------------------------------------------------------------------------------
Property				Meaning in Life								|
----------------------------------------------------------------------------------------------------------------
CallbackContract			Establishes whether this service contract requires callback 		|
					functionality for two-way message exchange (e.g., duplex bindings).	|
ConfigurationName			Locates the service element in an application configuration file.	|
					The default is the name of the service implementation class.		|
ProtectionLevel				Allows you to specify the degree to which the contract binding requires	|
					encryption, digital signatures, or both for endpoints that expose the	|
					contract.								|
SessionMode				Establishes whether sessions are allowed, not allowed, or required by	|
					this service contract.							|
----------------------------------------------------------------------------------------------------------------

Various Named Properties of the [OperationContract] Attribute
----------------------------------------------------------------------------------------------------------------
Property				Meaning in Life								|
----------------------------------------------------------------------------------------------------------------
AsyncPattern				Indicates whether the operation is implemented asynchronously using	|
					a Begin/End method pair on the service. This allows the service to	|
					offload processing to another server-side thread; this has nothing	|
					to do with the client calling the method asynchronously!		|
IsInitiating				Specifies whether this operation can be the initial operation in a 	|
					session.								|
IsOneWay				Indicates whether the operation consists of only a single input message	|
					(and no associated input).						|
IsTerminating				Specifies whether the WCF runtime should attempt to terminate the	|
					current session after the operation completes.				|
----------------------------------------------------------------------------------------------------------------

When you build a host for a WCF service type, you follow a predictable set of steps - some that rely on
configuration and some that rely on code. These steps are as follows:
- define the endpoint for the WCF service being hosted within the host's configuration file
- programmatically use the ServiceHost type to expose the service types available from this endpoint
- ensure the host remains running to service incoming client requests. Obviously, this step is not required
if you host your service types using a Windows service or IIS

In the world of WCF, the term endpoint represents the address, binding, and contract rolled together in a nice,
tidy package. In XML, an endpoint is expressed using the <endpoint> element and the address, binding, and
contract elements.

Select Members of the ServiceHost Type
----------------------------------------------------------------------------------------------------------------
Members					Meaning in Life								|
----------------------------------------------------------------------------------------------------------------
Authorization				This property gets the authorization level for the service behind	|
					hosted.									|
AddDefaultEndpoints()			This method is used to configure a WCF Service host programmatically	|
					so it uses any number of prebuilt endpoints supplied by the framework.	|
AddServiceEndpoint()			This method allows you to register an endpoint to the host		|
					programmatically.							|
BaseAddresses				This property obtains the list of registered base addresses for the	|
					current service.							|
BeginOpen()				These methods allow you to open and close a ServiceHost object		|
BeginClose()				asynchronously, using the standard asynchronous .NET delegate syntax.	|
CloseTimeout				This property allows you to set and get the time allowed for the 	|
					service to close down.							|
Credentials				This property obtains the security credentials used by the current	|
					service.								|
EndOpen() 				These methods  are the asynchronous counterparts to BeginOpen() and	|
EndClose()				BeginClose().								|
OpenTimeout				This property allows you to set and get the time allowed for the 	|
					service	to start up.							|
State					This property gets a value that indicates the current state of the	|
					communication object, which is represented by the CommunicationState	|
					enum (e.g., opened, closed, and created).				|
----------------------------------------------------------------------------------------------------------------

Select Subelements of <service.serviceModel>
----------------------------------------------------------------------------------------------------------------
Subelement				Meaning in Life								|
----------------------------------------------------------------------------------------------------------------
behaviors				WCF supports various endpoint and service behaviors. In a nutshell,	|
					a behavior allows you to qualify further the fucntionality of a host,	|
					service, or client.							|
bindings				This element allows you to fine-tune each of the WCF-supplied bindings	|
					(e.g., basicHttpBinding and netMsmqBinding), as well as to specify	|
					any custom binding used by the host.					|
client					This element contains a list of endpoint a client uses to connect to a	|
					service. Obviously, this is not particularly useful in a host's 	|
					*.config file.								|
comContracts				This element defines COM contracts enabled for WCF and COM 		|
					interoperability.							|
commonBehaviors				This elementcan be set only within a machine.config file. You can use 	|
					it to define all of the behaviors used by each WCF service on a given	|
					machine.								|
diagnostics				This element contains settings for the diagnostics features of WCF.	|
					The user can enable/disable tracing, performance counters, and the WMI	|
					provider; the user can also add custom message filters.			|
services				This element contains a collection of WCF services exposed by the host.	|
----------------------------------------------------------------------------------------------------------------

MEX - metadata exchange

While it is true that a desktop Windows application does not have to show a main window, a typical *.exe does
require user interaction to load the executable. However, you can configure a Windows service to run even if no
users are currently logged on to the workstation.

When you create a web-centric WCF service, you will find your project contains a specific file with an *.svc
file extension. This particular file is required for any WCF service hosted by IIS; it described the name and
location of the service implementation within the install point.

				PART VII - Windows Presentation Foundation

		Chapter 26 - Introducing Windows Presentation Foundation and XAML

WPF - Windows Presentation Foundation
XAML - Extensible Application Markup Language

While many full-featured desktop applications have been successfully created using Windows Forms, the fact
of matter is that this programming model is rather assymmetrical. Simply put, System.Windows.Forms.dll and
System.Drawing.dll do not provide direct support for many additional technologies to build a feature-rich
desktop application.

Pre-WPF Solutions to Desired Functionalities
----------------------------------------------------------------------------------------------------------------
Desired Functionality				Technology							|
----------------------------------------------------------------------------------------------------------------
Building windows with controls			Windows Forms							|
2D graphics support				GDI+ (System.Drawing.dll)					|
3D graphics support				DirectX APIs							|
Support for streaming video			Windows Media Player APIs					|
Support for flow-style documents		Programmatic manipulation of PDF files				|
----------------------------------------------------------------------------------------------------------------

.NET 3.0 Solutions to Desired Functionalities
----------------------------------------------------------------------------------------------------------------
Desired Functionality				Technology							|
----------------------------------------------------------------------------------------------------------------
Building windows with controls			WPF								|
2D graphics support				WPF								|
3D graphics support				WPF								|
Support for streaming video			WPF								|
Support for flow-style documents		WPF								|
----------------------------------------------------------------------------------------------------------------

XAML is not limited to WPF applications. Any application can use XAML to describe a tree of .NET objects, even if
they have nothing to do with a visible user interface. For example, the Windows Workflow Foundation API uses a
XAML-based grammar to define business processes and custom activities. As well, other .NET GUI frameworks such as
Silverlight (on the wane, but still very much in use today), Windows Phone, and Windows 10 applications all make 
use of XAML.

The WPF programming model is quite different in that GDI is not used when rendering graphical data. All rendering
operations (e.g., 2D graphics, 3D graphics, animations, control rendering, etc.) now make use of the DirectX API.
The first obvious benefit is that your WPF applications will automatically take advantange of hardware and 
software optimizations. As well, WPF applications can tap into very rich graphical services (blur effect, 
anti-aliasing, transparency, etc.) without the complexity of programming directly against the DirectX API.

Core WPF Assemblies
----------------------------------------------------------------------------------------------------------------
Assembly					Meaning in Life							|
----------------------------------------------------------------------------------------------------------------
PresentationCore.dll				This assembly defines numerous namespaces that constitute	|
						the foundation of the WPF GUI layer. For example, this assembly	|
						contains support for the WPF Ink API (for programming against	|
						stylus input for Pocket PCs and Tablet PCs), animation		|
						primitives, and numerous graphical rendering types.		|
PresentationFramework.dll			This assembly contains a majority of the WPF controls,		|
						the Application and Window classes, support for interactive 2D	|
						graphics and numerous types used in data binding.		|
System.Xaml.dll					This assembly provides namespaces that allow you to program 	|
						against a XAML document at runtime. By and large, this library	|
						is only useful if you are authoring WPF support tools or need 	|
						absolute control over XAML at runtime.				|
WindowsBase.dll					This assembly defines types that constitute the infrastucture	|
						of the WPF API, including those representing WPF threading	|
						types, security types, various type converters, and support	|
						for dependency properties and routed events.			|
----------------------------------------------------------------------------------------------------------------

Core WPF Namespaces
----------------------------------------------------------------------------------------------------------------
Namespace					Meaning in Life							|
----------------------------------------------------------------------------------------------------------------
System.Windows					This is the root namespace of WPF. Here, you will find core	|
						classes (such as Application and Window) that are required	|
						by any WPF desktop project.					|	
System.Windows.Controls				Contains all of the expected WPF widgets, including types to	|
						build menu systems, tool tips, and numerous layout managers.	|
System.Windows.Data				Contains types to work wuth the WPF data-binding engine, as	|
						well as support for data-binding templates.			|
System.Windows.Documents			Contains types to work with the documents API, which allows you	|
						to integrate PDF-style functionality into your WPF 		|
						applications, via the XML Paper Specification (XPS) protocol.	|
System.Windows.Ink				Provides support for the Ink API, which allows you to capture	|
						input from a stylus or mouse, respond to input getstures, and	|
						so forth. Very useful for Tablet PC programming; hovewer, any	|
						WPF can make use of this API.					|
System.Windows.Markup				This namespace defines a number of types that allow XAML 	|
						markup (and the equivalent binary format, BAML) to be parsed 	|
						and processed programmatically.					|
System.Windows.Media				This is the root namespace to several media-centric namespaces.	|
						Within these namespaces you will find types to work with	|
						animations, 3D rendering, text rendering, and other		|
						multimedia primitives.						|
System.Windows.Navigation			This namespace provides types to account for the navigation	|
						logic employed by XAML browser applications (XBAPs) as well as	|
						standard desktop applications that require a navigational page	|
						model.								|
System.Windows.Shapes				Defines classes that allow you to render interactive 2D graphics|
						that automatically respond to mouse input.			|
----------------------------------------------------------------------------------------------------------------

Key Properties of the Application Type
----------------------------------------------------------------------------------------------------------------
Property					Meaning in Life							|
----------------------------------------------------------------------------------------------------------------
Current						This static property allows you to gain access to the		|
						running Application object from anywhere in your code. This	|
						can be very helpful when a window or dialog box needs to gain	|
						access to the Application object that created it, typically	|
						to access application-wide variables and functionality.		|
MainWindow					This property allows you to programmatically get or set the	|
						main window of the application.					|
Properties					This property allows you to establish and obtain data that is	|
						accessible throughout all aspects of a WPF application 		|
						(windows, dialog boxes, etc.).					|
StartupUri					This property gets or sets a URI that specifies a window or	|
						page to open automatically when the application starts.		|
Windows						This property returns a WindowCollection type, which provides	|
						access to each window created from the thread that created	|
						the Application object. This can be very helpful when you	|
						want to iterate over each open window of an application and	|
						alter its state (such as minimizing all windows).		|
----------------------------------------------------------------------------------------------------------------

XAML is an XML-based grammar that allows you to define the state (and, to some extent, the functionality) of a 
tree of .NET objects through markup. While XAML is frequently used when building UIs with WPF, in reality  it can
be used to describe any tree of nonabstract .NET types (including your own custom types defined in a custom 
.NET assembly), provided each supports a default constructor.
Because XAML is an XML-based grammar, we gain all the benefits (and drawbacks) XML affords us. On the plus side,
XAML files are very self-describing (as any XML document should be). By and large, each element in a XAML file
represents a type name (such as Button, Window, or Application) within a given .NET namespace. Attributes within
the scope of an opening element map to properties (Height, Width, etc.) and events (Startup, Click, etc.) of the
specified type.

XAML Keywords
----------------------------------------------------------------------------------------------------------------
XAML Keyword					Meaning in Life							|
----------------------------------------------------------------------------------------------------------------
x:Array						Represents a .NET array type in XAML.				|
x:ClassModifier					Allows you to define the visibility of the C# class (internal	|
						or public) denoted by the Class keyword.			|
x:FieldModifier					Allows you to define the visibility of a type member (internal,	|
						public, private, or protected) for any named subelement of the	|
						root (e.g., <Button> within a <Window> element). A named	|
						element is defined using the Name XAML keyword.			|
x:Key						Allows you to establish a key value for a XAML item that will 	|
						be placed into a dictionary element.				|
x:Name						Allows you to specify the generated C# name of a given XAML	|
						element.							|
x:Null						Represents a null reference.					|
x:Static					Allows you to make reference to a static member of a type.	|
x:Type						The XAML equivalent of the C# typeof operator (it will yield	|
						a System.Type based on the supplied name).			|
x:TypeArguments					Allows you to establish an element as a generic type with a 	|
						specific type parameter (e.g., List<int> vs. List<bool>).	|
----------------------------------------------------------------------------------------------------------------

The XamlReader and XamlWriter classes provide basic functionality to manipulate XAML at runtime. If you ever
have a need to gain full control over the XAML object model, you will want to explore the System.Xaml.dll
assembly.

		Chapter 27 Programming with WPF Controls

Core WPF Panel Controls
----------------------------------------------------------------------------------------------------------------
Panel Control					Meaning in Life							|
----------------------------------------------------------------------------------------------------------------
Canvas						Provides a classic mode of content placement. Items stay 	|
						exactly where you put them at design time.			|
DockPanel					Locks content to a specified side of the panel (Top, Bottom,	|
						Left, or Right).						|
Grid						Arranges content within a series of cells, maintained within	|
						a tabular grid.							|
StackPanel					Stack content in a vertical or horizontal manner, as dictated	|
						by the Orientation property.					|
WrapPanel					Positions content from left-to-right, breaking the content to	|
						the next line at the edge of the containing box. Subsequent	|
						ordering happens sequentially from top-to-bottom or from	|
						right-to-left, depending on the value of the Orientation	|
						property.							|
----------------------------------------------------------------------------------------------------------------
			
If you do not define any rows or columns, the <Grid> defaults to a single cell that fills the entire surface
of the window. Futhermore, if you do not assign a cell value for a subelement within a <Grid>, it automatically
attaches to column 0, row 0.

The Padding property controls how much extra space should surround the interior control, while Margin controls
the extra space around the exterior of a control.

The Intrinsic WPF Control Command Objects
----------------------------------------------------------------------------------------------------------------
WPF Class			Command Objects				Meaning in Life				|
----------------------------------------------------------------------------------------------------------------
ApplicationCommands		Close, Copy, Cut, Delete, Find,		Various application-level commands	|
				Open, Paste, Save, SaveAs, Redo,						|
				Undo										|
ComponentCommands		MoveDown, MoveFocusBack, MoveLeft,	Various commands common to UI		|
				MoveRight, ScrollToEnd, 		components				|
				ScrollToHome									|
MediaCommands			BoostBase, ChannelUp, ChannelDown,	Various media-centric commands.		|
				FastForward, NextTrack, Play,							|
				Rewind, Select, Stop								|
NavigationCommands		BrowseBack, BrowseForward,		Various commands relating to the WPF	|
				Favorites, LastPage, NextPage, Zoom	navigation model			|
EditingCommands			AlignCenter, CorrectSpellingError,	Various commands relating to the WPF	|
				DecreaseFontSize, EnterLineBreak,	Documents API				|
				EnterParagraphBreak, MoveDownByLine,						|
				MoveRightByWord									|
----------------------------------------------------------------------------------------------------------------

Formally speaking, the items you add to an XPS document belong to one of two broad categories: block elements
and inline elements. This first category, block elements, consists of classes that extend the
System.Windows.Documents.Block base class. Examples of block elements include List, Paragraph, BlockUIContainer,
Section, and Table. You use classes from this category to group together other content (e.g., a list containing
paragraph data, and a paragraph containing subparagraphs for different text formatting).
The second category, inline elements, consists of classes that extend the System.Windows.Documents.Inline base
class. You nest inline elements within another block item (or possibly within another inline element inside a
block element). Some common inline elements include Run, Span, LineBreak, Figure, and Floater.

XPS Control Layout Managers
----------------------------------------------------------------------------------------------------------------
Panel Control					Meaning in Life							|
----------------------------------------------------------------------------------------------------------------
FlowDocumentReader				Displays data in a FlowDocument and adds support for zooming,	|
						searching, and content layout in various forms.			|
FlowDocumentScrollViewer			Displays data in a FlowDocument; hovewer, the data is presented	|
						in a single document viewed with scrollbars. This container	|
						does not support zooming, searching, or alternative layout	|
						models.								|
RichTextBox					Displays data in a FlowDocument and adds support for user	|
						editing.							|
FlowDocumentPageViewer				Displays the document page by page, one page at a time. Data	|
						can also be zoomed, but not searched.				|
----------------------------------------------------------------------------------------------------------------

Controls are often the target of various data-binding operations. Simply put, data binding is the act of connecting
control properties to data values that might change over the course of your application's lifetime. Doins so lets
a user interface element display the state of a variable in your code. For example, you might use data binding
to accomplish the following:
- check a CheckBox control based on a Boolean property of a given object
- display data in DataGrid objects from a relational database table
- connect a Label to an integer that represents the number of files in a folder
When you use the intrinsic WPF data-binding engine, you must be aware of the distinction between the source and 
the destination of the binding operation. As you might expect, the source of a data-binding operation is the data
itself (e.g., a Boolean property or relational data), while the destination (target) is the UI control property
that uses the data content (e.g., a property on a CheckBox or TextBox control).

	Chapter 28 WPF Graphics Rendering Services

WPF uses a particular flavor of graphical rendering that goes by the term rendering-mode graphics. Simply put,
this means that since you are using XAML or procedural code to generate graphical renderings, it is the 
responsibility of WPF to persist these visual items and ensure that they are correctly redrawn and refreshed 
in an optimal manner. Thus, when you render graphical data, it is always present, even when the end user hides
the image by resizing or minimizing the window, by covering the window with another, and so forth.

Select Members of the System.Windows.Media.Geometry Type
----------------------------------------------------------------------------------------------------------------
Member						Meaning in Life							|
----------------------------------------------------------------------------------------------------------------
Bounds						Establishes the current bounding rectangle containing the	|
						geometry.							|
FillContains()					Determines whether a given Point(or other Geometry object) is	|
						within the bounds of a particular Geometry-derived class.	|
						This is useful for hit-testing calculations.			|
GetArea()					Returns the entire area a Geometry-derived type occupies.	|
GetRenderBounds()				Returns a Rect that contains the smallest possible rectangle	|
						that could be used to render the Geometry-derived class.	|
Transform					Assings a Transform object to the geometry to alter the		|
						rendering.							|
----------------------------------------------------------------------------------------------------------------

Geometry-Derived Classes
----------------------------------------------------------------------------------------------------------------
Geometry Class					Meaning in Life							|
----------------------------------------------------------------------------------------------------------------
LineGeometry					Represents a straight line					|
RectangleGeometry				Represents a rectangle						|
EllipseGeometry					Represents an ellipse						|
GeometryGroup					Allows you to group together several Geometry objects		|
CombinedGeometry				Allows you to merge two different Geometry objects into a 	|
						single shape							|
PathGeometry					Represents a figure composed of lines and curves		|
----------------------------------------------------------------------------------------------------------------

WPF Brush-Derived Types
----------------------------------------------------------------------------------------------------------------
Brush Type					Meaning in Life							|
----------------------------------------------------------------------------------------------------------------
DrawingBrush					Paints an area with a Drawing-derived object (GeometryDrawing,	|
						ImageDrawing, or VideoDrawing)					|
ImageBrush					Pains an area with an image (represented by an ImageSource	|
						object)								|
LinearGradientBrush				Paints an area with a linear gradient				|
RadialGradientBrush				Paints an area with a radial gradient				|
SolidColorBrush					Paints a single color, set with the Color property		|
VisualBrush					Paints an area with a Visual-derived object (DrawingVisual,	|
						Viewport3DVisual, and ContainerVisual)				|
----------------------------------------------------------------------------------------------------------------

Key Descendants of the System.Windows.Media.Transform Type
----------------------------------------------------------------------------------------------------------------
Type						Meaning in Life							|
----------------------------------------------------------------------------------------------------------------
MatrixTransform					Creates an arbitrary matrix transformation that is used		|
						to manipulate objects or coordinate systems in a 2D plane	|
RotateTransform					Rotates an object clockwise about a specified point in a 	|
						2D (x, y) coordinate system					|
ScaleTransform					Scales an object in the 2D (x, y) coordinate system		|
SkewTransform					Skews an object in the 2D (x, y) coordinate system		|
TranslateTransform				Translates (moves) an object in the 2-D (x-y) coordinate system	|
TransformGroup					Represents a composite Transform composed of the Transform	|
						objects								|
----------------------------------------------------------------------------------------------------------------

Blend Transformation Options
----------------------------------------------------------------------------------------------------------------
Transformation Option				Meaning in Life							|
----------------------------------------------------------------------------------------------------------------
Translate					Allows you to offset the location of an item on an X, Y		|	
						position.							|
Rotate						Allows you to rotate an item on a 360-degree angle.		|
Scale						Allows you to grow or shrink an item by a factor in the X and	|
						Y directions.							|
Skew						Allows you to skew the bounding box containing the selected	|
						item by a factor in the X and Y directions.			|
Center Point					When you rotate or flip an object, the item moves relative to	|
						a fixed point, called the object's center point. By default,	|
						an object's center point is located at the object's center;	|
						however, this transformation allows you to change an object's	|
						center point in order to rotate or flip the object around a	|
						different point.						|
Flip						Flips a selected item based on an X or Y center point.		|
----------------------------------------------------------------------------------------------------------------

	Chapter 29 WPF Resources, Animations, Styles, and Templates

















p.1788






